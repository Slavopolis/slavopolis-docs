# å¿«é€Ÿä¸Šæ‰‹

`slavopolis-excel` æ˜¯ä¸€ä¸ªåŸºäº EasyExcel 4.0.3 å°è£…çš„ Excel å¤„ç†æ¡†æ¶ï¼Œæä¾› **æ³¨è§£é©±åŠ¨**ã€**ç±»å‹å®‰å…¨**ã€**é«˜æ€§èƒ½** çš„ Excel è¯»å†™å’Œæ¨¡æ¿å¡«å……èƒ½åŠ›ã€‚

## ä¸»è¦ç‰¹æ€§

- **ğŸ“ æ³¨è§£é©±åŠ¨**: åŸºäºæ³¨è§£çš„å£°æ˜å¼é…ç½®ï¼Œç®€åŒ–å¼€å‘ï¼›
- **ğŸ”’ ç±»å‹å®‰å…¨**: å®Œæ•´çš„æ³›å‹æ”¯æŒï¼Œç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥  ï¼›
- **âš¡ é«˜æ€§èƒ½**: æµå¼å¤„ç†ã€æ‰¹é‡æ“ä½œã€å¤šçº§ç¼“å­˜ï¼›
- **ğŸ”§ æ˜“æ‰©å±•**: æ’ä»¶åŒ–è½¬æ¢å™¨ã€å¤„ç†å™¨ã€ç›‘å¬å™¨ï¼›
- **ğŸš€ å¼‚æ­¥æ”¯æŒ**: CompletableFuture å¼‚æ­¥å¤„ç†ï¼›
- **ğŸ—ï¸ Spring é›†æˆ**: é›¶é…ç½®è‡ªåŠ¨è£…é…ï¼›

## æ–‡æ¡£ç›®å½•

1. [å¿«é€Ÿå¼€å§‹æŒ‡å—](#1-å¿«é€Ÿå¼€å§‹æŒ‡å—)
2. [è¯¦ç»†APIæ–‡æ¡£](#2-è¯¦ç»†apiæ–‡æ¡£)
3. [é…ç½®å±æ€§è¯¦è§£](#3-é…ç½®å±æ€§è¯¦è§£)
4. [ä½¿ç”¨ç¤ºä¾‹å¤§å…¨](#4-ä½¿ç”¨ç¤ºä¾‹å¤§å…¨)
5. [å¸¸è§é—®é¢˜è§£ç­”](#5-å¸¸è§é—®é¢˜è§£ç­”)
6. [æœ€ä½³å®è·µæŒ‡å—](#6-æœ€ä½³å®è·µæŒ‡å—)
7. [æ€§èƒ½è°ƒä¼˜å»ºè®®](#7-æ€§èƒ½è°ƒä¼˜å»ºè®®)
8. [æ•…éšœæ’æŸ¥æ‰‹å†Œ](#8-æ•…éšœæ’æŸ¥æ‰‹å†Œ)
9. [é«˜çº§æ‰©å±•æŒ‡å—](#9-é«˜çº§æ‰©å±•æŒ‡å—)
10. [é™„å½•å’Œå‚è€ƒ](#10-é™„å½•å’Œå‚è€ƒ)

## 1. å¿«é€Ÿå¼€å§‹æŒ‡å—

### 1.1 ç¯å¢ƒè¦æ±‚

| ç»„ä»¶            | ç‰ˆæœ¬è¦æ±‚ | è¯´æ˜                      |
| --------------- | -------- | ------------------------- |
| **JDK**         | 17+      | æ¨èä½¿ç”¨ JDK 21 LTS       |
| **Spring Boot** | 3.0+     | æ”¯æŒ Spring Boot 3.x ç³»åˆ— |
| **Maven**       | 3.6+     | æ„å»ºå·¥å…·                  |

### 1.2 å¿«é€Ÿé›†æˆ

#### æ­¥éª¤1ï¼šæ·»åŠ ä¾èµ–

ç›®å‰ä»…æä¾› Maven ä¾èµ–ç®¡ç†æ–¹æ¡ˆï¼š
```xml
<dependency>
    <groupId>club.slavopolis</groupId>
    <artifactId>slavopolis-excel</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</dependency>
```

#### æ­¥éª¤2ï¼šå¯ç”¨è‡ªåŠ¨é…ç½®

åœ¨ `application.yml` ä¸­æ·»åŠ é…ç½®ï¼š

```yaml
slavopolis:
  excel:
    enabled: true  # å¯ç”¨ExcelåŠŸèƒ½
```

#### æ­¥éª¤3ï¼šåˆ›å»ºå®ä½“ç±»

```java
@Data
@ExcelSheet(value = "ç”¨æˆ·ä¿¡æ¯", description = "ç”¨æˆ·åŸºæœ¬ä¿¡æ¯è¡¨")
public class User {
    
    @ExcelField(value = "ç”¨æˆ·ID", index = 0, required = true)
    private Long id;
    
    @ExcelField(value = "ç”¨æˆ·å", index = 1, required = true, maxLength = 50)
    private String username;
    
    @ExcelField(value = "é‚®ç®±", index = 2, pattern = "^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$")
    private String email;
    
    @ExcelField(value = "åˆ›å»ºæ—¶é—´", index = 3, dateFormat = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createTime;
    
    @ExcelField(value = "çŠ¶æ€", index = 4, defaultValue = "æ­£å¸¸")
    private String status;
}
```

#### æ­¥éª¤4ï¼šä½¿ç”¨æœåŠ¡

```java
@Service
public class UserExcelService {
    
    @Autowired
    private AnnotationExcelService annotationExcelService;
    
    /**
     * è¯»å–Excelæ–‡ä»¶
     */
    public List<User> readUsers(String filePath) {
        ExcelReadResult<User> result = annotationExcelService.read(filePath, User.class);
        
        if (result.isSuccess()) {
            return result.getData();
        } else {
            // å¤„ç†é”™è¯¯
            result.getErrors().forEach(error -> 
                log.error("ç¬¬{}è¡Œå‡ºé”™: {}", error.getRowIndex(), error.getErrorMessage())
            );
            return Collections.emptyList();
        }
    }
    
    /**
     * å†™å…¥Excelæ–‡ä»¶
     */
    public boolean writeUsers(List<User> users, String filePath) {
        ExcelWriteResult result = annotationExcelService.write(filePath, users, User.class);
        return result.isSuccess();
    }
}
```

### 1.3 äº”åˆ†é’Ÿä½“éªŒ

åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹åº”ç”¨ï¼š

```java
@RestController
@RequestMapping("/api/excel")
public class ExcelController {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    /**
     * ä¸Šä¼ å¹¶è§£æExcelæ–‡ä»¶
     */
    @PostMapping("/upload")
    public ResponseEntity<?> uploadExcel(@RequestParam("file") MultipartFile file) {
        try {
            // ç›´æ¥ä»ä¸Šä¼ çš„æ–‡ä»¶æµè¯»å–
            ExcelReadResult<User> result = excelService.read(file.getInputStream(), User.class);
            
            if (result.isSuccess()) {
                return ResponseEntity.ok(Map.of(
                    "success", true,
                    "message", "å¯¼å…¥æˆåŠŸ",
                    "total", result.getData().size(),
                    "data", result.getData()
                ));
            } else {
                return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "message", "å¯¼å…¥å¤±è´¥",
                    "errors", result.getErrors()
                ));
            }
        } catch (Exception e) {
            return ResponseEntity.status(500).body(Map.of(
                "success", false,
                "message", "ç³»ç»Ÿé”™è¯¯ï¼š" + e.getMessage()
            ));
        }
    }
    
    /**
     * å¯¼å‡ºExcelæ–‡ä»¶
     */
    @GetMapping("/export")
    public void exportExcel(HttpServletResponse response) throws IOException {
        // æ¨¡æ‹Ÿæ•°æ®
        List<User> users = Arrays.asList(
            new User(1L, "å¼ ä¸‰", "zhangsan@example.com", LocalDateTime.now(), "æ­£å¸¸"),
            new User(2L, "æå››", "lisi@example.com", LocalDateTime.now(), "æ­£å¸¸")
        );
        
        // è®¾ç½®å“åº”å¤´
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setHeader("Content-Disposition", "attachment; filename=users.xlsx");
        
        // ç›´æ¥å†™å…¥å“åº”æµ
        excelService.write(response.getOutputStream(), users, User.class);
    }
}
```

### 1.4 è¿è¡ŒéªŒè¯

å¯åŠ¨åº”ç”¨åï¼Œè®¿é—®ä»¥ä¸‹æ¥å£ï¼š

- **ä¸Šä¼ **: `POST /api/excel/upload` - ä¸Šä¼  Excel æ–‡ä»¶è¿›è¡Œè§£æ
- **å¯¼å‡º**: `GET /api/excel/export` - ä¸‹è½½ Excel æ–‡ä»¶

ğŸ‰ **æ­å–œï¼** æ‚¨å·²ç»æˆåŠŸé›†æˆäº† slavopolis-excelï¼Œå¯ä»¥è¿›è¡ŒåŸºæœ¬çš„ Excel è¯»å†™æ“ä½œã€‚

## 2. è¯¦ç»†APIæ–‡æ¡£

### 2.1 æ ¸å¿ƒæœåŠ¡æ¥å£

#### 2.1.1 AnnotationExcelService

åŸºäºæ³¨è§£é©±åŠ¨çš„é«˜çº§ Excel æœåŠ¡ï¼Œ**æ¨èä½¿ç”¨**ã€‚

```java
@Service
public class AnnotationExcelService {
    
    // =============== è¯»å–æ“ä½œ ===============
    
    /**
     * åŒæ­¥è¯»å–Excelæ–‡ä»¶
     * @param filePath æ–‡ä»¶è·¯å¾„
     * @param clazz ç›®æ ‡ç±»å‹
     * @return è¯»å–ç»“æœ
     */
    public <T> ExcelReadResult<T> read(String filePath, Class<T> clazz);
    
    /**
     * ä»è¾“å…¥æµè¯»å–Excel
     * @param inputStream è¾“å…¥æµ
     * @param clazz ç›®æ ‡ç±»å‹
     * @return è¯»å–ç»“æœ
     */
    public <T> ExcelReadResult<T> read(InputStream inputStream, Class<T> clazz);
    
    /**
     * å¼‚æ­¥è¯»å–Excelæ–‡ä»¶
     * @param filePath æ–‡ä»¶è·¯å¾„
     * @param clazz ç›®æ ‡ç±»å‹
     * @return Futureç»“æœ
     */
    public <T> CompletableFuture<ExcelReadResult<T>> readAsync(String filePath, Class<T> clazz);
    
    // =============== å†™å…¥æ“ä½œ ===============
    
    /**
     * å†™å…¥Excelæ–‡ä»¶
     * @param filePath è¾“å‡ºè·¯å¾„
     * @param data æ•°æ®åˆ—è¡¨
     * @param clazz æ•°æ®ç±»å‹
     * @return å†™å…¥ç»“æœ
     */
    public <T> ExcelWriteResult write(String filePath, List<T> data, Class<T> clazz);
    
    /**
     * å†™å…¥åˆ°è¾“å‡ºæµ
     * @param outputStream è¾“å‡ºæµ
     * @param data æ•°æ®åˆ—è¡¨
     * @param clazz æ•°æ®ç±»å‹
     * @return å†™å…¥ç»“æœ
     */
    public <T> ExcelWriteResult write(OutputStream outputStream, List<T> data, Class<T> clazz);
    
    /**
     * å¼‚æ­¥å†™å…¥Excelæ–‡ä»¶
     * @param filePath è¾“å‡ºè·¯å¾„
     * @param data æ•°æ®åˆ—è¡¨
     * @param clazz æ•°æ®ç±»å‹
     * @return Futureç»“æœ
     */
    public <T> CompletableFuture<ExcelWriteResult> writeAsync(String filePath, List<T> data, Class<T> clazz);
    
    // =============== æ¨¡æ¿å¡«å…… ===============
    
    /**
     * åŸºäºæ³¨è§£è¿›è¡Œæ¨¡æ¿å¡«å……
     * @param outputPath è¾“å‡ºè·¯å¾„
     * @param data å¡«å……æ•°æ®
     * @param clazz æ•°æ®ç±»å‹ï¼ˆå¿…é¡»æœ‰@ExcelTemplateæ³¨è§£ï¼‰
     * @return å¡«å……ç»“æœ
     */
    public <T> ExcelFillResult fill(String outputPath, T data, Class<T> clazz);
    
    /**
     * å¡«å……åˆ°è¾“å‡ºæµ
     * @param outputStream è¾“å‡ºæµ
     * @param data å¡«å……æ•°æ®
     * @param clazz æ•°æ®ç±»å‹
     * @return å¡«å……ç»“æœ
     */
    public <T> ExcelFillResult fill(OutputStream outputStream, T data, Class<T> clazz);
    
    /**
     * å¼‚æ­¥æ¨¡æ¿å¡«å……
     * @param outputPath è¾“å‡ºè·¯å¾„
     * @param data å¡«å……æ•°æ®
     * @param clazz æ•°æ®ç±»å‹
     * @return Futureç»“æœ
     */
    public <T> CompletableFuture<ExcelFillResult> fillAsync(String outputPath, T data, Class<T> clazz);
}
```

#### 2.1.2 ExcelService

ä¼ ç»Ÿçš„ Excel æœåŠ¡æ¥å£ï¼Œæä¾›æ›´çµæ´»çš„é…ç½®ã€‚

```java
public interface ExcelService {
    
    // è¯»å–æ“ä½œ
    <T> ExcelReadResult<T> read(ExcelReadRequest<T> request);
    <T> CompletableFuture<ExcelReadResult<T>> readAsync(ExcelReadRequest<T> request);
    <T> ExcelReadResult<T> readStream(ExcelReadRequest<T> request, Consumer<T> dataConsumer);
    
    // å†™å…¥æ“ä½œ  
    ExcelWriteResult write(ExcelWriteRequest request);
    CompletableFuture<ExcelWriteResult> writeAsync(ExcelWriteRequest request);
    ExcelWriteResult writeMultiSheet(ExcelMultiSheetWriteRequest request);
    
    // æ¨¡æ¿å¡«å……
    ExcelFillResult fill(ExcelFillRequest request);
    CompletableFuture<ExcelFillResult> fillAsync(ExcelFillRequest request);
    ExcelFillResult fillBatch(List<ExcelFillRequest> requests);
    
    // å·¥å…·æ–¹æ³•
    boolean isValidExcelFile(String filePath);
    long getFileSizeBytes(String filePath);
    ExcelFileInfo getFileInfo(String filePath);
}
```

### 2.2 æ³¨è§£è¯¦è§£

#### 2.2.1 @ExcelSheet

æ ‡æ³¨ç±»ä¸ Excel å·¥ä½œè¡¨çš„æ˜ å°„å…³ç³»ã€‚

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelSheet {
    
    /**
     * Sheetåç§°ï¼Œé»˜è®¤ä½¿ç”¨ç±»å
     */
    String value() default "";
    
    /**
     * Sheetç´¢å¼•ï¼Œä»0å¼€å§‹ï¼Œé»˜è®¤0
     */
    int index() default 0;
    
    /**
     * æ ‡é¢˜è¡Œç´¢å¼•ï¼Œä»0å¼€å§‹ï¼Œé»˜è®¤0
     */
    int headerIndex() default 0;
    
    /**
     * æ•°æ®å¼€å§‹è¡Œç´¢å¼•ï¼Œä»0å¼€å§‹ï¼Œé»˜è®¤1
     */
    int dataStartIndex() default 1;
    
    /**
     * æ˜¯å¦åŒ…å«æ ‡é¢˜è¡Œï¼Œé»˜è®¤true
     */
    boolean includeHeader() default true;
    
    /**
     * æ˜¯å¦å¿½ç•¥ç©ºè¡Œï¼Œé»˜è®¤true
     */
    boolean ignoreEmptyRow() default true;
    
    /**
     * æ˜¯å¦è‡ªåŠ¨å»é™¤ç©ºæ ¼ï¼Œé»˜è®¤true
     */
    boolean autoTrim() default true;
    
    /**
     * æœ€å¤§è¯»å–è¡Œæ•°ï¼Œ0è¡¨ç¤ºä¸é™åˆ¶ï¼Œé»˜è®¤0
     */
    int maxRows() default 0;
    
    /**
     * æœ€å¤§è¯»å–åˆ—æ•°ï¼Œ0è¡¨ç¤ºä¸é™åˆ¶ï¼Œé»˜è®¤0
     */
    int maxColumns() default 0;
    
    /**
     * å¯†ç ï¼ˆå¦‚æœExcelæ–‡ä»¶æœ‰å¯†ç ä¿æŠ¤ï¼‰
     */
    String password() default "";
    
    /**
     * æ˜¯å¦å¯ç”¨æ•°æ®éªŒè¯ï¼Œé»˜è®¤true
     */
    boolean enableValidation() default true;
    
    /**
     * æ˜¯å¦å¿«é€Ÿå¤±è´¥ï¼ˆé‡åˆ°é”™è¯¯ç«‹å³åœæ­¢ï¼‰ï¼Œé»˜è®¤false
     */
    boolean failFast() default false;
    
    /**
     * æè¿°ä¿¡æ¯
     */
    String description() default "";
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```java
@ExcelSheet(
    value = "å‘˜å·¥ä¿¡æ¯",
    headerIndex = 0,
    dataStartIndex = 1,
    maxRows = 10000,
    enableValidation = true,
    description = "å‘˜å·¥åŸºæœ¬ä¿¡æ¯å¯¼å…¥è¡¨"
)
public class Employee {
    // å­—æ®µå®šä¹‰...
}
```

#### 2.2.2 @ExcelField

æ ‡æ³¨å­—æ®µä¸ Excel åˆ—çš„æ˜ å°„å…³ç³»ã€‚

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelField {
    
    /**
     * åˆ—æ ‡é¢˜ï¼Œé»˜è®¤ä½¿ç”¨å­—æ®µå
     */
    String value() default "";
    
    /**
     * åˆ—ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰ï¼Œ-1è¡¨ç¤ºè‡ªåŠ¨æ¨æ–­
     */
    int index() default -1;
    
    /**
     * æ˜¯å¦å¿…å¡«ï¼Œé»˜è®¤false
     */
    boolean required() default false;
    
    /**
     * é»˜è®¤å€¼
     */
    String defaultValue() default "";
    
    /**
     * æ•°æ®è½¬æ¢å™¨
     */
    Class<? extends ExcelDataConverter<?>> converter() default ExcelDataConverter.class;
    
    /**
     * æ—¥æœŸæ ¼å¼ï¼ˆé’ˆå¯¹æ—¥æœŸç±»å‹ï¼‰
     */
    String dateFormat() default "yyyy-MM-dd HH:mm:ss";
    
    /**
     * æ•°å­—æ ¼å¼ï¼ˆé’ˆå¯¹æ•°å­—ç±»å‹ï¼‰
     */
    String numberFormat() default "";
    
    /**
     * æœ€å¤§é•¿åº¦
     */
    int maxLength() default Integer.MAX_VALUE;
    
    /**
     * æœ€å°é•¿åº¦
     */
    int minLength() default 0;
    
    /**
     * æ­£åˆ™è¡¨è¾¾å¼éªŒè¯
     */
    String pattern() default "";
    
    /**
     * éªŒè¯é”™è¯¯æ¶ˆæ¯
     */
    String message() default "";
    
    /**
     * æ˜¯å¦å¿½ç•¥è¯¥å­—æ®µ
     */
    boolean ignore() default false;
    
    /**
     * åˆ—å®½åº¦ï¼ˆå­—ç¬¦æ•°ï¼‰
     */
    int width() default -1;
    
    /**
     * å•å…ƒæ ¼æ ·å¼
     */
    String cellStyle() default "";
    
    /**
     * æ˜¯å¦è‡ªåŠ¨è°ƒæ•´åˆ—å®½
     */
    boolean autoWidth() default false;
    
    /**
     * æ’åºåºå·ï¼ˆç”¨äºæ§åˆ¶åˆ—çš„æ˜¾ç¤ºé¡ºåºï¼‰
     */
    int order() default Integer.MAX_VALUE;
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```java
public class Product {
    
    @ExcelField(value = "å•†å“ID", index = 0, required = true, message = "å•†å“IDä¸èƒ½ä¸ºç©º")
    private Long id;
    
    @ExcelField(value = "å•†å“åç§°", index = 1, required = true, maxLength = 100)
    private String name;
    
    @ExcelField(value = "ä»·æ ¼", index = 2, numberFormat = "#,##0.00")
    private BigDecimal price;
    
    @ExcelField(value = "åˆ›å»ºæ—¶é—´", index = 3, dateFormat = "yyyy-MM-dd")
    private LocalDate createDate;
    
    @ExcelField(value = "å•†å“ç¼–ç ", index = 4, pattern = "^[A-Z]{2}\\d{6}$", 
                message = "å•†å“ç¼–ç æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º2ä¸ªå¤§å†™å­—æ¯+6ä½æ•°å­—")
    private String code;
    
    @ExcelField(ignore = true)  // å¿½ç•¥è¯¥å­—æ®µ
    private String internalNotes;
}
```

#### 2.2.3 @ExcelTemplate

æ ‡æ³¨æ¨¡æ¿å¡«å……ç›¸å…³é…ç½®ã€‚

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelTemplate {
    
    /**
     * æ¨¡æ¿è·¯å¾„ï¼ˆå¿…å¡«ï¼‰
     */
    String value();
    
    /**
     * æ¨¡æ¿åç§°ï¼Œç”¨äºæ¨¡æ¿æ³¨å†Œï¼Œé»˜è®¤ä½¿ç”¨ç±»å
     */
    String name() default "";
    
    /**
     * å¡«å……æ–¹å‘ï¼ˆtrue=æ¨ªå‘å¡«å……ï¼Œfalse=çºµå‘å¡«å……ï¼‰ï¼Œé»˜è®¤false
     */
    boolean horizontal() default false;
    
    /**
     * èµ·å§‹å¡«å……è¡Œï¼ˆä»0å¼€å§‹ï¼‰ï¼Œé»˜è®¤0
     */
    int startRow() default 0;
    
    /**
     * èµ·å§‹å¡«å……åˆ—ï¼ˆä»0å¼€å§‹ï¼‰ï¼Œé»˜è®¤0
     */
    int startColumn() default 0;
    
    /**
     * æ˜¯å¦å¼ºåˆ¶æ–°å»ºSheetï¼Œé»˜è®¤false
     */
    boolean forceNewSheet() default false;
    
    /**
     * æ˜¯å¦å¯ç”¨å…¬å¼è®¡ç®—ï¼Œé»˜è®¤true
     */
    boolean enableFormula() default true;
    
    /**
     * æ˜¯å¦è‡ªåŠ¨è°ƒæ•´è¡Œé«˜ï¼Œé»˜è®¤false
     */
    boolean autoRowHeight() default false;
    
    /**
     * æ˜¯å¦è‡ªåŠ¨è°ƒæ•´åˆ—å®½ï¼Œé»˜è®¤false
     */
    boolean autoColumnWidth() default false;
    
    /**
     * æ¨¡æ¿ç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œ0è¡¨ç¤ºä¸ç¼“å­˜ï¼Œé»˜è®¤300ç§’
     */
    int cacheSeconds() default 300;
    
    /**
     * æè¿°ä¿¡æ¯
     */
    String description() default "";
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```java
@ExcelTemplate(
    value = "classpath:templates/invoice.xlsx",
    name = "invoice_template",
    startRow = 5,
    startColumn = 1,
    enableFormula = true,
    cacheSeconds = 1800,
    description = "å‘ç¥¨æ¨¡æ¿"
)
public class Invoice {
    
    @ExcelField("å‘ç¥¨å·ç ")
    private String invoiceNumber;
    
    @ExcelField("å¼€ç¥¨æ—¥æœŸ")
    private LocalDate issueDate;
    
    @ExcelField("å®¢æˆ·åç§°")
    private String customerName;
    
    @ExcelField("é‡‘é¢")
    private BigDecimal amount;
}
```

### 2.3 è¯·æ±‚å’Œå“åº”æ¨¡å‹

#### 2.3.1 ExcelReadResult

Excel è¯»å–æ“ä½œçš„ç»“æœã€‚

```java
@Data
@Builder
public class ExcelReadResult<T> {
    
    /**
     * æ˜¯å¦æˆåŠŸ
     */
    private boolean success;
    
    /**
     * è¯»å–åˆ°çš„æ•°æ®åˆ—è¡¨
     */
    private List<T> data;
    
    /**
     * é”™è¯¯åˆ—è¡¨
     */
    private List<ExcelError> errors;
    
    /**
     * æ€»è¡Œæ•°
     */
    private int totalRows;
    
    /**
     * æˆåŠŸè¡Œæ•°
     */
    private int successRows;
    
    /**
     * å¤±è´¥è¡Œæ•°
     */
    private int failureRows;
    
    /**
     * å¤„ç†è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
     */
    private long processingTimeMs;
    
    /**
     * é¢å¤–ä¿¡æ¯
     */
    private Map<String, Object> metadata;
    
    // ä¾¿æ·æ–¹æ³•
    public boolean hasErrors() { return errors != null && !errors.isEmpty(); }
    public int getErrorCount() { return errors != null ? errors.size() : 0; }
    public double getSuccessRate() { return totalRows > 0 ? (double) successRows / totalRows : 0; }
}
```

#### 2.3.2 ExcelWriteResult

Excel å†™å…¥æ“ä½œçš„ç»“æœã€‚

```java
@Data
@Builder
public class ExcelWriteResult {
    
    /**
     * æ˜¯å¦æˆåŠŸ
     */
    private boolean success;
    
    /**
     * é”™è¯¯ä¿¡æ¯
     */
    private String errorMessage;
    
    /**
     * å†™å…¥çš„æ•°æ®è¡Œæ•°
     */
    private int writtenRows;
    
    /**
     * è¾“å‡ºæ–‡ä»¶è·¯å¾„
     */
    private String outputPath;
    
    /**
     * æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
     */
    private long fileSizeBytes;
    
    /**
     * å¤„ç†è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
     */
    private long processingTimeMs;
    
    /**
     * é¢å¤–ä¿¡æ¯
     */
    private Map<String, Object> metadata;
}
```

#### 2.3.3 ExcelError

Excel å¤„ç†è¿‡ç¨‹ä¸­çš„é”™è¯¯ä¿¡æ¯ã€‚

```java
@Data
@Builder
public class ExcelError {
    
    /**
     * è¡Œç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰
     */
    private int rowIndex;
    
    /**
     * åˆ—ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰
     */
    private int columnIndex;
    
    /**
     * å­—æ®µåç§°
     */
    private String fieldName;
    
    /**
     * å•å…ƒæ ¼å€¼
     */
    private String cellValue;
    
    /**
     * é”™è¯¯æ¶ˆæ¯
     */
    private String errorMessage;
    
    /**
     * é”™è¯¯ç 
     */
    private ExcelErrorCode errorCode;
    
    /**
     * é”™è¯¯å‘ç”Ÿæ—¶é—´
     */
    private LocalDateTime timestamp;
    
    /**
     * é”™è¯¯ä¸Šä¸‹æ–‡
     */
    private Map<String, Object> context;
}
```

## 3. é…ç½®å±æ€§è¯¦è§£

### 3.1 å®Œæ•´é…ç½®ç¤ºä¾‹

```yaml
slavopolis:
  excel:
    # åŸºç¡€é…ç½®
    enabled: true  # æ˜¯å¦å¯ç”¨ExcelåŠŸèƒ½ï¼Œé»˜è®¤true
    
    # éªŒè¯é…ç½®
    validation:
      max-file-size: 52428800      # æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼Œé»˜è®¤50MB
      max-rows: 100000               # æœ€å¤§è¡Œæ•°ï¼Œé»˜è®¤100000
      max-columns: 256               # æœ€å¤§åˆ—æ•°ï¼Œé»˜è®¤256
      allowed-extensions:             # å…è®¸çš„æ–‡ä»¶æ‰©å±•å
        - xlsx
        - xls
        - csv
    
    # å¼‚æ­¥å¤„ç†é…ç½®
    async:
      file-size-threshold: 10485760    # æ–‡ä»¶å¤§å°é˜ˆå€¼ï¼ˆè¶…è¿‡æ­¤å¤§å°å°†ä½¿ç”¨å¼‚æ­¥å¤„ç†ï¼‰ï¼Œé»˜è®¤10MB
      thread-pool:
        core-size: 4                  						# æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œé»˜è®¤4
        max-size: 8                  						 # æœ€å¤§çº¿ç¨‹æ•°ï¼Œé»˜è®¤8
        queue-capacity: 100          			 # é˜Ÿåˆ—å®¹é‡ï¼Œé»˜è®¤100
        keep-alive: 60              					 # çº¿ç¨‹ç©ºé—²æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤60
        name-prefix: "excel-async-"   # çº¿ç¨‹åå‰ç¼€
    
    # æ€§èƒ½é…ç½®
    performance:
      default-batch-size: 1000           # é»˜è®¤æ‰¹æ¬¡å¤§å°ï¼Œé»˜è®¤1000
      memory-threshold: 5000          # å†…å­˜ä¼˜åŒ–é˜ˆå€¼ï¼Œé»˜è®¤5000
      enable-cache: true                    # æ˜¯å¦å¯ç”¨ç¼“å­˜ï¼Œé»˜è®¤true
      cache-expire-seconds: 3600     # ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤3600
    
    # é”™è¯¯å¤„ç†é…ç½®
    error:
      fail-fast: false               					 # æ˜¯å¦å¿«é€Ÿå¤±è´¥ï¼Œé»˜è®¤false
      max-errors: 100                			# æœ€å¤§é”™è¯¯æ•°é‡ï¼Œé»˜è®¤100
      collect-detail: true           				# æ˜¯å¦æ”¶é›†è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼Œé»˜è®¤true
    
    # æ³¨è§£å¤„ç†é…ç½®
    annotation:
      enabled: true                  				# æ˜¯å¦å¯ç”¨æ³¨è§£å¤„ç†ï¼Œé»˜è®¤true
      cache-enabled: true               # æ˜¯å¦å¯ç”¨å…ƒæ•°æ®ç¼“å­˜ï¼Œé»˜è®¤true
      cache-size: 500                     # ç¼“å­˜å¤§å°ï¼Œé»˜è®¤500
    
    # ç›‘æ§é…ç½®
    monitoring:
      enabled: true                 			 # æ˜¯å¦å¯ç”¨ç›‘æ§ï¼Œé»˜è®¤true
      performance-stats: true        # æ˜¯å¦å¯ç”¨æ€§èƒ½ç»Ÿè®¡ï¼Œé»˜è®¤true
      jvm-monitoring: true           # æ˜¯å¦å¯ç”¨JVMç›‘æ§ï¼Œé»˜è®¤true
    
    # æ¨¡æ¿é…ç½®
    template:
      base-path: "classpath:excel/templates/"  		# æ¨¡æ¿æ–‡ä»¶æ ¹è·¯å¾„
      cache-enabled: true                     							 # æ˜¯å¦å¯ç”¨æ¨¡æ¿ç¼“å­˜ï¼Œé»˜è®¤true
      cache-size: 100                          									# ç¼“å­˜å¤§å°ï¼Œé»˜è®¤100
      scan-packages:                          								 # æ¨¡æ¿æ–‡ä»¶æ‰«æè·¯å¾„
        - "**.excel.template"
```

### 3.2 é…ç½®é¡¹è¯¦ç»†è¯´æ˜

#### 3.2.1 åŸºç¡€é…ç½®

| å±æ€§                       | ç±»å‹    | é»˜è®¤å€¼ | è¯´æ˜                                       |
| -------------------------- | ------- | ------ | ------------------------------------------ |
| `slavopolis.excel.enabled` | Boolean | true   | æ˜¯å¦å¯ç”¨ExcelåŠŸèƒ½ï¼Œè®¾ä¸ºfalseåˆ™å®Œå…¨ç¦ç”¨æ¨¡å— |

#### 3.2.2 éªŒè¯é…ç½®

| å±æ€§                            | ç±»å‹         | é»˜è®¤å€¼         | è¯´æ˜                                 |
| ------------------------------- | ------------ | -------------- | ------------------------------------ |
| `validation.max-file-size`      | Long         | 52428800       | æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼Œè¶…è¿‡å°†æ‹’ç»å¤„ç† |
| `validation.max-rows`           | Integer      | 100000         | æœ€å¤§è¡Œæ•°é™åˆ¶ï¼Œé˜²æ­¢å†…å­˜æº¢å‡º           |
| `validation.max-columns`        | Integer      | 256            | æœ€å¤§åˆ—æ•°é™åˆ¶                         |
| `validation.allowed-extensions` | List<String> | [xlsx,xls,csv] | å…è®¸çš„æ–‡ä»¶æ‰©å±•ååˆ—è¡¨                 |

#### 3.2.3 å¼‚æ­¥å¤„ç†é…ç½®

| å±æ€§                               | ç±»å‹    | é»˜è®¤å€¼   | è¯´æ˜                                     |
| ---------------------------------- | ------- | -------- | ---------------------------------------- |
| `async.file-size-threshold`        | Long    | 10485760 | å¼‚æ­¥å¤„ç†é˜ˆå€¼ï¼Œæ–‡ä»¶è¶…è¿‡æ­¤å¤§å°è‡ªåŠ¨ä½¿ç”¨å¼‚æ­¥ |
| `async.thread-pool.core-size`      | Integer | 4        | å¼‚æ­¥å¤„ç†çº¿ç¨‹æ± æ ¸å¿ƒçº¿ç¨‹æ•°                 |
| `async.thread-pool.max-size`       | Integer | 8        | å¼‚æ­¥å¤„ç†çº¿ç¨‹æ± æœ€å¤§çº¿ç¨‹æ•°                 |
| `async.thread-pool.queue-capacity` | Integer | 100      | å¼‚æ­¥å¤„ç†çº¿ç¨‹æ± é˜Ÿåˆ—å®¹é‡                   |
| `async.thread-pool.keep-alive`     | Integer | 60       | çº¿ç¨‹ç©ºé—²ä¿æ´»æ—¶é—´ï¼ˆç§’ï¼‰                   |

#### 3.2.4 æ€§èƒ½é…ç½®

| å±æ€§                               | ç±»å‹    | é»˜è®¤å€¼ | è¯´æ˜                               |
| ---------------------------------- | ------- | ------ | ---------------------------------- |
| `performance.default-batch-size`   | Integer | 1000   | é»˜è®¤æ‰¹å¤„ç†å¤§å°ï¼Œå½±å“å†…å­˜ä½¿ç”¨å’Œæ€§èƒ½ |
| `performance.memory-threshold`     | Integer | 5000   | å†…å­˜ä¼˜åŒ–é˜ˆå€¼ï¼Œè¶…è¿‡å°†å¯ç”¨æµå¼å¤„ç†   |
| `performance.enable-cache`         | Boolean | true   | æ˜¯å¦å¯ç”¨ç¼“å­˜æœºåˆ¶                   |
| `performance.cache-expire-seconds` | Integer | 3600   | ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰                 |

### 3.3 ç¯å¢ƒç‰¹å®šé…ç½®

#### 3.3.1 å¼€å‘ç¯å¢ƒé…ç½®

```yaml
# application-dev.yml
slavopolis:
  excel:
    validation:
      max-file-size: 10485760  # å¼€å‘ç¯å¢ƒé™åˆ¶10MB
      max-rows: 5000
    error:
      fail-fast: true         					 # å¼€å‘ç¯å¢ƒå¿«é€Ÿå¤±è´¥ï¼Œä¾¿äºè°ƒè¯•
      collect-detail: true
    monitoring:
      enabled: true
      performance-stats: true
```

#### 3.3.2 ç”Ÿäº§ç¯å¢ƒé…ç½®

```yaml
# application-prod.yml
slavopolis:
  excel:
    validation:
      max-file-size: 104857600  # ç”Ÿäº§ç¯å¢ƒ100MB
      max-rows: 50000
    async:
      thread-pool:
        core-size: 8
        max-size: 16
    performance:
      default-batch-size: 2000  # ç”Ÿäº§ç¯å¢ƒæ›´å¤§æ‰¹æ¬¡
      enable-cache: true
    error:
      fail-fast: false          				# ç”Ÿäº§ç¯å¢ƒå®¹é”™
      max-errors: 1000
    monitoring:
      enabled: true
      jvm-monitoring: true
```

## 4. ä½¿ç”¨ç¤ºä¾‹å¤§å…¨

### 4.1 åŸºç¡€è¯»å†™ç¤ºä¾‹

#### 4.1.1 ç®€å•æ•°æ®è¯»å†™

å®šä¹‰å®ä½“ç±»ï¼š

```java
@Data
@ExcelSheet("å­¦ç”Ÿä¿¡æ¯")
public class Student {
    @ExcelField(value = "å­¦å·", index = 0, required = true)
    private String studentId;
    
    @ExcelField(value = "å§“å", index = 1, required = true, maxLength = 50)
    private String name;
    
    @ExcelField(value = "å¹´é¾„", index = 2)
    private Integer age;
    
    @ExcelField(value = "é‚®ç®±", index = 3, pattern = "^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$")
    private String email;
}
```

æœåŠ¡ç±»å®ç°ï¼š

```java
@Service
public class StudentService {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    /**
     * å¯¼å…¥å­¦ç”Ÿæ•°æ®
     */
    public ImportResult importStudents(MultipartFile file) {
        try {
            ExcelReadResult<Student> result = excelService.read(file.getInputStream(), Student.class);
            
            if (result.isSuccess()) {
                // ä¿å­˜åˆ°æ•°æ®åº“
                List<Student> students = result.getData();
                studentRepository.saveAll(students);
                
                return ImportResult.success()
                    .message("å¯¼å…¥æˆåŠŸ")
                    .total(students.size())
                    .build();
            } else {
                // å¤„ç†é”™è¯¯
                return ImportResult.failure()
                    .message("å¯¼å…¥å¤±è´¥")
                    .errors(result.getErrors())
                    .build();
            }
        } catch (Exception e) {
            log.error("å¯¼å…¥å­¦ç”Ÿæ•°æ®å¤±è´¥", e);
            return ImportResult.error("ç³»ç»Ÿé”™è¯¯ï¼š" + e.getMessage());
        }
    }
    
    /**
     * å¯¼å‡ºå­¦ç”Ÿæ•°æ®
     */
    public void exportStudents(HttpServletResponse response, StudentQueryDto queryDto) {
        try {
            // æŸ¥è¯¢æ•°æ®
            List<Student> students = studentRepository.findByConditions(queryDto);
            
            // è®¾ç½®å“åº”å¤´
            String fileName = "å­¦ç”Ÿæ•°æ®_" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")) + ".xlsx";
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            response.setHeader("Content-Disposition", "attachment; filename=" + URLEncoder.encode(fileName, "UTF-8"));
            
            // å¯¼å‡ºExcel
            ExcelWriteResult result = excelService.write(response.getOutputStream(), students, Student.class);
            
            if (!result.isSuccess()) {
                throw new BusinessException("å¯¼å‡ºå¤±è´¥ï¼š" + result.getErrorMessage());
            }
            
        } catch (Exception e) {
            log.error("å¯¼å‡ºå­¦ç”Ÿæ•°æ®å¤±è´¥", e);
            throw new BusinessException("å¯¼å‡ºå¤±è´¥ï¼š" + e.getMessage());
        }
    }
}
```

#### 4.1.2 å¤æ‚æ•°æ®ç±»å‹å¤„ç†

```java
@Data
@ExcelSheet(value = "è®¢å•ä¿¡æ¯", description = "è®¢å•è¯¦ç»†ä¿¡æ¯")
public class Order {
    
    @ExcelField(value = "è®¢å•ID", index = 0, required = true)
    private Long orderId;
    
    @ExcelField(value = "è®¢å•ç¼–å·", index = 1, required = true, pattern = "^ORD\\d{8}$")
    private String orderNumber;
    
    @ExcelField(value = "å®¢æˆ·åç§°", index = 2, required = true, maxLength = 100)
    private String customerName;
    
    @ExcelField(value = "è®¢å•é‡‘é¢", index = 3, numberFormat = "#,##0.00")
    private BigDecimal amount;
    
    @ExcelField(value = "è®¢å•çŠ¶æ€", index = 4, converter = OrderStatusConverter.class)
    private OrderStatus status;
    
    @ExcelField(value = "åˆ›å»ºæ—¶é—´", index = 5, dateFormat = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createTime;
    
    @ExcelField(value = "äº¤ä»˜æ—¥æœŸ", index = 6, dateFormat = "yyyy-MM-dd")
    private LocalDate deliveryDate;
    
    @ExcelField(value = "å¤‡æ³¨", index = 7, maxLength = 500)
    private String remarks;
    
    @ExcelField(value = "æ˜¯å¦ç´§æ€¥", index = 8, converter = BooleanConverter.class)
    private Boolean urgent;
}
```

è‡ªå®šä¹‰çŠ¶æ€è½¬æ¢å™¨ï¼šï¼ˆçŠ¶æ€è½¬æ¢ç¤ºä¾‹ï¼‰

```java
@Component
public class OrderStatusConverter implements ExcelDataConverter<OrderStatus> {
    
    @Override
    public OrderStatus convertToJavaData(String cellValue, ExcelContentProperty contentProperty, 
                                       GlobalConfiguration globalConfiguration) {
        if (StringUtils.isBlank(cellValue)) {
            return null;
        }
        
        switch (cellValue.trim()) {
            case "å¾…ä»˜æ¬¾": return OrderStatus.PENDING_PAYMENT;
            case "å·²ä»˜æ¬¾": return OrderStatus.PAID;
            case "å·²å‘è´§": return OrderStatus.SHIPPED;
            case "å·²å®Œæˆ": return OrderStatus.COMPLETED;
            case "å·²å–æ¶ˆ": return OrderStatus.CANCELLED;
            default:
                throw new IllegalArgumentException("æœªçŸ¥çš„è®¢å•çŠ¶æ€ï¼š" + cellValue);
        }
    }
    
    @Override
    public String convertToExcelData(OrderStatus value, ExcelContentProperty contentProperty, 
                                   GlobalConfiguration globalConfiguration) {
        if (value == null) {
            return "";
        }
        
        switch (value) {
            case PENDING_PAYMENT: return "å¾…ä»˜æ¬¾";
            case PAID: return "å·²ä»˜æ¬¾";
            case SHIPPED: return "å·²å‘è´§";
            case COMPLETED: return "å·²å®Œæˆ";
            case CANCELLED: return "å·²å–æ¶ˆ";
            default: return value.name();
        }
    }
    
    @Override
    public Class<OrderStatus> supportJavaTypeKey() {
        return OrderStatus.class;
    }
}
```

è‡ªå®šä¹‰çŠ¶æ€è½¬æ¢å™¨ï¼šï¼ˆå¸ƒå°”è½¬æ¢ç¤ºä¾‹ï¼‰

```java
@Component
public class BooleanConverter implements ExcelDataConverter<Boolean> {
    
    @Override
    public Boolean convertToJavaData(String cellValue, ExcelContentProperty contentProperty, 
                                   GlobalConfiguration globalConfiguration) {
        if (StringUtils.isBlank(cellValue)) {
            return false;
        }
        
        String value = cellValue.trim().toLowerCase();
        return "æ˜¯".equals(value) || "true".equals(value) || "1".equals(value) || "yes".equals(value);
    }
    
    @Override
    public String convertToExcelData(Boolean value, ExcelContentProperty contentProperty, 
                                   GlobalConfiguration globalConfiguration) {
        return value != null && value ? "æ˜¯" : "å¦";
    }
    
    @Override
    public Class<Boolean> supportJavaTypeKey() {
        return Boolean.class;
    }
}
```

### 4.2 æ¨¡æ¿å¡«å……ç¤ºä¾‹

#### 4.2.1 å‘ç¥¨æ¨¡æ¿å¡«å……

 å®šä¹‰å‘ç¥¨æ•°æ®æ¨¡å‹ï¼š

```java
@Data
@ExcelTemplate(
    value = "classpath:templates/invoice_template.xlsx",
    name = "invoice",
    startRow = 5,
    startColumn = 1,
    enableFormula = true,
    description = "å‘ç¥¨æ¨¡æ¿"
)
public class Invoice {
    
    @ExcelField("å‘ç¥¨å·ç ")
    private String invoiceNumber;
    
    @ExcelField("å¼€ç¥¨æ—¥æœŸ")
    private LocalDate issueDate;
    
    @ExcelField("å®¢æˆ·åç§°")
    private String customerName;
    
    @ExcelField("å®¢æˆ·åœ°å€")
    private String customerAddress;
    
    @ExcelField("ç¨å·")
    private String taxNumber;
    
    @ExcelField("æ˜ç»†")
    private List<InvoiceItem> items;
    
    @ExcelField("å°è®¡")
    private BigDecimal subtotal;
    
    @ExcelField("ç¨é¢")
    private BigDecimal tax;
    
    @ExcelField("æ€»è®¡")
    private BigDecimal total;
}
```

```java
@Data
public class InvoiceItem {
    @ExcelField("åºå·")
    private Integer serialNumber;
    
    @ExcelField("å•†å“åç§°")
    private String productName;
    
    @ExcelField("è§„æ ¼")
    private String specification;
    
    @ExcelField("æ•°é‡")
    private Integer quantity;
    
    @ExcelField("å•ä»·")
    private BigDecimal unitPrice;
    
    @ExcelField("é‡‘é¢")
    private BigDecimal amount;
}
```

å‘ç¥¨æœåŠ¡ï¼š

```java
@Service
public class InvoiceService {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    /**
     * ç”Ÿæˆå‘ç¥¨
     */
    public void generateInvoice(Long invoiceId, HttpServletResponse response) {
        try {
            // è·å–å‘ç¥¨æ•°æ®
            Invoice invoice = buildInvoiceData(invoiceId);
            
            // è®¾ç½®å“åº”å¤´
            String fileName = "å‘ç¥¨_" + invoice.getInvoiceNumber() + ".xlsx";
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            response.setHeader("Content-Disposition", "attachment; filename=" + URLEncoder.encode(fileName, "UTF-8"));
            
            // å¡«å……æ¨¡æ¿
            ExcelFillResult result = excelService.fill(response.getOutputStream(), invoice, Invoice.class);
            
            if (!result.isSuccess()) {
                throw new BusinessException("å‘ç¥¨ç”Ÿæˆå¤±è´¥ï¼š" + result.getErrorMessage());
            }
            
        } catch (Exception e) {
            log.error("ç”Ÿæˆå‘ç¥¨å¤±è´¥ï¼ŒinvoiceId: {}", invoiceId, e);
            throw new BusinessException("å‘ç¥¨ç”Ÿæˆå¤±è´¥ï¼š" + e.getMessage());
        }
    }
    
    private Invoice buildInvoiceData(Long invoiceId) {
        // ä»æ•°æ®åº“è·å–å‘ç¥¨ä¿¡æ¯
        InvoiceEntity entity = invoiceRepository.findById(invoiceId)
            .orElseThrow(() -> new BusinessException("å‘ç¥¨ä¸å­˜åœ¨"));
        
        // æ„å»ºå‘ç¥¨æ•°æ®
        Invoice invoice = new Invoice();
        invoice.setInvoiceNumber(entity.getInvoiceNumber());
        invoice.setIssueDate(entity.getIssueDate());
        invoice.setCustomerName(entity.getCustomerName());
        // ... è®¾ç½®å…¶ä»–å­—æ®µ
        
        // æ„å»ºæ˜ç»†æ•°æ®
        List<InvoiceItem> items = entity.getItems().stream()
            .map(this::convertToInvoiceItem)
            .collect(Collectors.toList());
        invoice.setItems(items);
        
        // è®¡ç®—æ€»é‡‘é¢
        BigDecimal subtotal = items.stream()
            .map(InvoiceItem::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        invoice.setSubtotal(subtotal);
        
        BigDecimal tax = subtotal.multiply(new BigDecimal("0.13")); // 13%ç¨ç‡
        invoice.setTax(tax);
        invoice.setTotal(subtotal.add(tax));
        
        return invoice;
    }
}
```

#### 4.2.2 æŠ¥è¡¨æ¨¡æ¿å¡«å……

æœˆåº¦é”€å”®æŠ¥è¡¨æ¨¡æ¿ï¼š

```java
@Data
@ExcelTemplate(
    value = "classpath:templates/monthly_sales_report.xlsx",
    name = "monthly_sales",
    horizontal = false,
    startRow = 3,
    cacheSeconds = 1800
)
public class MonthlySalesReport {
    
    @ExcelField("æŠ¥è¡¨æœˆä»½")
    private String reportMonth;
    
    @ExcelField("æŠ¥è¡¨ç”Ÿæˆæ—¶é—´")
    private LocalDateTime generateTime;
    
    @ExcelField("æ€»é”€å”®é¢")
    private BigDecimal totalSales;
    
    @ExcelField("é”€å”®ç›®æ ‡")
    private BigDecimal salesTarget;
    
    @ExcelField("å®Œæˆç‡")
    private String completionRate;
    
    @ExcelField("é”€å”®æ˜ç»†")
    private List<SalesDetail> salesDetails;
    
    @ExcelField("ç»Ÿè®¡æ±‡æ€»")
    private SalesSummary summary;
}
```

```java
@Data
public class SalesDetail {
    @ExcelField("æ—¥æœŸ")
    private LocalDate saleDate;
    
    @ExcelField("é”€å”®å‘˜")
    private String salesperson;
    
    @ExcelField("å®¢æˆ·")
    private String customer;
    
    @ExcelField("äº§å“")
    private String product;
    
    @ExcelField("æ•°é‡")
    private Integer quantity;
    
    @ExcelField("é‡‘é¢")
    private BigDecimal amount;
}
```

æŠ¥è¡¨æœåŠ¡ï¼š

```java
@Service
public class ReportService {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    /**
     * ç”Ÿæˆæœˆåº¦é”€å”®æŠ¥è¡¨
     */
    public CompletableFuture<String> generateMonthlySalesReportAsync(String yearMonth) {
        return excelService.fillAsync("reports/monthly_sales_" + yearMonth + ".xlsx", 
                                     buildMonthlySalesData(yearMonth), 
                                     MonthlySalesReport.class)
            .thenApply(result -> {
                if (result.isSuccess()) {
                    return result.getOutputPath();
                } else {
                    throw new BusinessException("æŠ¥è¡¨ç”Ÿæˆå¤±è´¥ï¼š" + result.getErrorMessage());
                }
            });
    }
}
```

### 4.3 é«˜çº§ç‰¹æ€§ç¤ºä¾‹

#### 4.3.1 å¤š Sheet å¤„ç†

å¤š Sheet å†™å…¥ç¤ºä¾‹ï¼š

```java
@Service
public class MultiSheetExcelService {
    
    @Autowired
    private ExcelService excelService;
    
    public void exportMultiSheetData(String filePath) {
        // æ„å»ºå¤šSheetå†™å…¥è¯·æ±‚
        ExcelMultiSheetWriteRequest request = ExcelMultiSheetWriteRequest.builder()
            .outputPath(filePath)
            .sheets(Arrays.asList(
                // Sheet1: ç”¨æˆ·ä¿¡æ¯
                ExcelSheetWriteRequest.builder()
                    .sheetName("ç”¨æˆ·ä¿¡æ¯")
                    .dataClass(User.class)
                    .data(getUserList())
                    .build(),
                    
                // Sheet2: è®¢å•ä¿¡æ¯    
                ExcelSheetWriteRequest.builder()
                    .sheetName("è®¢å•ä¿¡æ¯")
                    .dataClass(Order.class)
                    .data(getOrderList())
                    .build(),
                    
                // Sheet3: äº§å“ä¿¡æ¯
                ExcelSheetWriteRequest.builder()
                    .sheetName("äº§å“ä¿¡æ¯")
                    .dataClass(Product.class)
                    .data(getProductList())
                    .build()
            ))
            .build();
            
        ExcelWriteResult result = excelService.writeMultiSheet(request);
        
        if (!result.isSuccess()) {
            throw new BusinessException("å¤šSheetå¯¼å‡ºå¤±è´¥ï¼š" + result.getErrorMessage());
        }
    }
}
```

#### 4.3.2 æµå¼å¤„ç†å¤§æ–‡ä»¶

```java
@Service
public class LargeFileProcessingService {
    
    @Autowired
    private ExcelService excelService;
    
    @Autowired
    private DataProcessor<User> userDataProcessor;
    
    /**
     * æµå¼å¤„ç†å¤§æ–‡ä»¶
     */
    public void processLargeFile(String filePath) {
        
        // æ„å»ºæµå¼è¯»å–è¯·æ±‚
        ExcelReadRequest<User> request = ExcelReadRequest.<User>builder()
            .filePath(filePath)
            .dataClass(User.class)
            .processor(userDataProcessor)
            .config(ReadConfig.builder()
                .batchSize(1000)  // æ‰¹æ¬¡å¤§å°
                .enableStreamProcessing(true)  // å¯ç”¨æµå¼å¤„ç†
                .build())
            .build();
        
        // ä½¿ç”¨æµå¼å¤„ç†ï¼Œé¿å…å†…å­˜æº¢å‡º
        ExcelReadResult<User> result = excelService.readStream(request, user -> {
            // å¤„ç†æ¯ä¸ªç”¨æˆ·æ•°æ®
            processUserData(user);
        });
        
        log.info("æµå¼å¤„ç†å®Œæˆï¼Œå…±å¤„ç†{}è¡Œæ•°æ®", result.getTotalRows());
    }
    
    private void processUserData(User user) {
        // å…·ä½“çš„ä¸šåŠ¡å¤„ç†é€»è¾‘
        // æ¯”å¦‚ï¼šæ•°æ®éªŒè¯ã€æ¸…æ´—ã€ä¿å­˜åˆ°æ•°æ®åº“ç­‰
        if (isValidUser(user)) {
            userRepository.save(user);
        }
    }
}
```

#### 4.3.3 å¼‚æ­¥æ‰¹é‡å¤„ç†

```java
@Service
public class AsyncBatchProcessingService {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * å¼‚æ­¥æ‰¹é‡å¯¼å…¥ç”¨æˆ·
     */
    public CompletableFuture<BatchImportResult> importUsersAsync(List<MultipartFile> files, String operatorId) {
        
        List<CompletableFuture<ExcelReadResult<User>>> futures = files.stream()
            .map(file -> processFileAsync(file, operatorId))
            .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> {
                // æ±‡æ€»æ‰€æœ‰ç»“æœ
                BatchImportResult batchResult = new BatchImportResult();
                
                for (CompletableFuture<ExcelReadResult<User>> future : futures) {
                    try {
                        ExcelReadResult<User> result = future.get();
                        batchResult.addResult(result);
                    } catch (Exception e) {
                        log.error("è·å–å¼‚æ­¥å¤„ç†ç»“æœå¤±è´¥", e);
                        batchResult.addError("å¤„ç†å¤±è´¥ï¼š" + e.getMessage());
                    }
                }
                
                // å‘é€é€šçŸ¥
                notificationService.sendImportNotification(operatorId, batchResult);
                
                return batchResult;
            });
    }
    
    private CompletableFuture<ExcelReadResult<User>> processFileAsync(MultipartFile file, String operatorId) {
        return excelService.readAsync(file.getInputStream(), User.class)
            .thenApply(result -> {
                if (result.isSuccess()) {
                    // ä¿å­˜ç”¨æˆ·æ•°æ®
                    userRepository.saveAll(result.getData());
                    log.info("æ–‡ä»¶{}å¤„ç†å®Œæˆï¼Œå…±å¯¼å…¥{}æ¡ç”¨æˆ·æ•°æ®", file.getOriginalFilename(), result.getData().size());
                } else {
                    log.error("æ–‡ä»¶{}å¤„ç†å¤±è´¥ï¼Œé”™è¯¯æ•°é‡ï¼š{}", file.getOriginalFilename(), result.getErrorCount());
                }
                return result;
            })
            .exceptionally(ex -> {
                log.error("å¼‚æ­¥å¤„ç†æ–‡ä»¶{}å¤±è´¥", file.getOriginalFilename(), ex);
                return ExcelReadResult.<User>builder()
                    .success(false)
                    .errors(Arrays.asList(ExcelError.builder()
                        .errorMessage("ç³»ç»Ÿé”™è¯¯ï¼š" + ex.getMessage())
                        .timestamp(LocalDateTime.now())
                        .build()))
                    .build();
            });
    }
}
```

### 4.4 æ•°æ®éªŒè¯ç¤ºä¾‹

#### 4.4.1 è‡ªå®šä¹‰éªŒè¯å™¨

è‡ªå®šä¹‰éªŒè¯æ³¨è§£ï¼š

```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneNumberValidator.class)
public @interface PhoneNumber {
    String message() default "æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

éªŒè¯å™¨å®ç°ï¼š

```java
@Component
public class PhoneNumberValidator implements ConstraintValidator<PhoneNumber, String> {
    
    private static final Pattern PHONE_PATTERN = Pattern.compile("^1[3-9]\\d{9}$");
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (StringUtils.isBlank(value)) {
            return true; // ç”±@NotNullæ§åˆ¶æ˜¯å¦å¿…å¡«
        }
        return PHONE_PATTERN.matcher(value).matches();
    }
}
```

ä½¿ç”¨éªŒè¯æ³¨è§£çš„å®ä½“ï¼š

```java
@Data
@ExcelSheet("ç”¨æˆ·è”ç³»ä¿¡æ¯")
public class UserContact {
    
    @ExcelField(value = "ç”¨æˆ·ID", index = 0, required = true)
    @NotNull(message = "ç”¨æˆ·IDä¸èƒ½ä¸ºç©º")
    private Long userId;
    
    @ExcelField(value = "æ‰‹æœºå·", index = 1, required = true)
    @NotBlank(message = "æ‰‹æœºå·ä¸èƒ½ä¸ºç©º")
    @PhoneNumber  // è‡ªå®šä¹‰éªŒè¯
    private String phoneNumber;
    
    @ExcelField(value = "é‚®ç®±", index = 2)
    @Email(message = "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")
    private String email;
    
    @ExcelField(value = "å¹´é¾„", index = 3)
    @Min(value = 0, message = "å¹´é¾„ä¸èƒ½å°äº0")
    @Max(value = 120, message = "å¹´é¾„ä¸èƒ½å¤§äº120")
    private Integer age;
}
```

å¸¦éªŒè¯çš„æ•°æ®å¤„ç†å™¨ï¼š

```java
@Component
public class ValidatedDataProcessor<T> implements DataProcessor<T> {
    
    @Autowired
    private Validator validator;
    
    @Override
    public ProcessResult<T> preProcess(T data, ProcessContext context) {
        // æ‰§è¡ŒBean Validation
        Set<ConstraintViolation<T>> violations = validator.validate(data);
        
        if (!violations.isEmpty()) {
            List<String> errorMessages = violations.stream()
                .map(ConstraintViolation::getMessage)
                .collect(Collectors.toList());
            
            return ProcessResult.failure(String.join("; ", errorMessages));
        }
        
        return ProcessResult.success(data);
    }
    
    @Override
    public ProcessResult<T> process(T data, ProcessContext context) {
        // è‡ªå®šä¹‰ä¸šåŠ¡éªŒè¯
        return validateBusinessRules(data, context);
    }
    
    private ProcessResult<T> validateBusinessRules(T data, ProcessContext context) {
        // å®ç°å…·ä½“çš„ä¸šåŠ¡éªŒè¯é€»è¾‘
        return ProcessResult.success(data);
    }
}
```

## 5. å¸¸è§é—®é¢˜è§£ç­”

### 5.1 åŸºç¡€é—®é¢˜

#### Q1: å¦‚ä½•åˆ¤æ–­ Excel æ–‡ä»¶æ ¼å¼æ˜¯å¦æ­£ç¡®ï¼Ÿ

**A:** ä½¿ç”¨å†…ç½®çš„æ–‡ä»¶éªŒè¯åŠŸèƒ½ï¼š

```java
@Service
public class FileValidationService {
    
    @Autowired
    private ExcelService excelService;
    
    public ValidationResult validateExcelFile(MultipartFile file) {
        try {
            // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            String fileName = file.getOriginalFilename();
            if (!isValidExcelExtension(fileName)) {
                return ValidationResult.error("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œä»…æ”¯æŒ.xlsxã€.xlsæ ¼å¼");
            }
            
            // æ£€æŸ¥æ–‡ä»¶å¤§å°
            if (file.getSize() > 50 * 1024 * 1024) { // 50MB
                return ValidationResult.error("æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶ï¼ˆ50MBï¼‰");
            }
            
            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯è¯»
            if (!excelService.isValidExcelFile(file.getInputStream())) {
                return ValidationResult.error("æ–‡ä»¶æŸåæˆ–æ ¼å¼é”™è¯¯");
            }
            
            return ValidationResult.success("æ–‡ä»¶éªŒè¯é€šè¿‡");
            
        } catch (Exception e) {
            return ValidationResult.error("æ–‡ä»¶éªŒè¯å¤±è´¥ï¼š" + e.getMessage());
        }
    }
    
    private boolean isValidExcelExtension(String fileName) {
        if (StringUtils.isBlank(fileName)) {
            return false;
        }
        String extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
        return Arrays.asList("xlsx", "xls").contains(extension);
    }
}
```

#### Q2: å¦‚ä½•å¤„ç† Excel ä¸­çš„ç©ºè¡Œå’Œç©ºåˆ—ï¼Ÿ

**A:** é€šè¿‡æ³¨è§£é…ç½®æ§åˆ¶ï¼š

```java
@ExcelSheet(
    value = "æ•°æ®è¡¨",
    ignoreEmptyRow = true,  // å¿½ç•¥ç©ºè¡Œ
    autoTrim = true         // è‡ªåŠ¨å»é™¤ç©ºæ ¼
)
public class DataEntity {
    
    @ExcelField(value = "å­—æ®µ1", required = true, defaultValue = "é»˜è®¤å€¼")
    private String field1;
    
    @ExcelField(value = "å­—æ®µ2", ignore = true)  // å¿½ç•¥è¯¥åˆ—
    private String field2;
}

// åœ¨è¯»å–æ—¶è¿›ä¸€æ­¥è¿‡æ»¤
public List<DataEntity> readAndFilter(String filePath) {
    ExcelReadResult<DataEntity> result = excelService.read(filePath, DataEntity.class);
    
    return result.getData().stream()
        .filter(entity -> StringUtils.isNotBlank(entity.getField1()))  // è¿‡æ»¤ç©ºæ•°æ®
        .collect(Collectors.toList());
}
```

#### Q3: å¦‚ä½•è‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯ï¼Ÿ

**A:** é€šè¿‡å¤šç§æ–¹å¼è‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯ï¼š

```java
public class CustomErrorMessages {
    
    // 1. æ³¨è§£ä¸­ç›´æ¥æŒ‡å®š
    @ExcelField(value = "é‚®ç®±", pattern = "^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$", 
                message = "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€")
    private String email;
    
    // 2. è‡ªå®šä¹‰é”™è¯¯æ”¶é›†å™¨
    @Component
    public class CustomErrorCollector extends ExcelErrorCollector {
        
        @Override
        public void addError(ExcelError error) {
            // è‡ªå®šä¹‰é”™è¯¯ä¿¡æ¯æ ¼å¼
            String customMessage = String.format("ç¬¬%dè¡Œç¬¬%dåˆ—ï¼š%sï¼ˆåŸå€¼ï¼š%sï¼‰", 
                error.getRowIndex() + 1, 
                error.getColumnIndex() + 1,
                error.getErrorMessage(),
                error.getCellValue());
            
            error.setErrorMessage(customMessage);
            super.addError(error);
        }
    }
    
    // 3. å›½é™…åŒ–é”™è¯¯ä¿¡æ¯
    @Component
    public class I18nErrorHandler {
        
        @Autowired
        private MessageSource messageSource;
        
        public String getLocalizedErrorMessage(String errorCode, Object... args) {
            return messageSource.getMessage(errorCode, args, LocaleContextHolder.getLocale());
        }
    }
}
```

### 5.2 æ€§èƒ½é—®é¢˜

#### Q4: å¦‚ä½•å¤„ç†å¤§æ–‡ä»¶å¯¼è‡´çš„å†…å­˜æº¢å‡ºï¼Ÿ

**A:** ä½¿ç”¨æµå¼å¤„ç†å’Œåˆç†çš„é…ç½®ï¼š

```yaml
# application.yml
slavopolis:
  excel:
    performance:
      memory-threshold: 5000      # è¶…è¿‡5000è¡Œä½¿ç”¨æµå¼å¤„ç†
      default-batch-size: 1000   # æ‰¹å¤„ç†å¤§å°
    async:
      file-size-threshold: 10485760  # è¶…è¿‡10MBä½¿ç”¨å¼‚æ­¥å¤„ç†
```

```java
@Service
public class LargeFileHandler {
    
    /**
     * å¤„ç†å¤§æ–‡ä»¶çš„æ¨èæ–¹å¼
     */
    public void handleLargeFile(String filePath) {
        
        // æ–¹å¼1ï¼šä½¿ç”¨æµå¼å¤„ç†
        ExcelReadRequest<User> request = ExcelReadRequest.<User>builder()
            .filePath(filePath)
            .dataClass(User.class)
            .config(ReadConfig.builder()
                .enableStreamProcessing(true)
                .batchSize(500)  // å°æ‰¹æ¬¡å¤„ç†
                .build())
            .build();
        
        excelService.readStream(request, user -> {
            // é€æ¡å¤„ç†ï¼ŒåŠæ—¶é‡Šæ”¾å†…å­˜
            processUserImmediately(user);
        });
    }
    
    private void processUserImmediately(User user) {
        // å…·ä½“çš„ä¸šåŠ¡å¤„ç†é€»è¾‘
        // æ¯”å¦‚ï¼šæ•°æ®éªŒè¯ã€æ¸…æ´—ã€ä¿å­˜åˆ°æ•°æ®åº“ç­‰
        if (isValidUser(user)) {
            userRepository.save(user);
        }
    }
}
```

#### Q5: å¦‚ä½•ä¼˜åŒ–å¯¼å‡ºæ€§èƒ½ï¼Ÿ

**A:** é‡‡ç”¨å¤šç§ä¼˜åŒ–ç­–ç•¥ï¼š

```java
@Service
public class OptimizedExportService {
    
    @Autowired
    private ExcelService excelService;
    
    /**
     * ä¼˜åŒ–çš„å¯¼å‡ºå®ç°
     */
    public void optimizedExport(HttpServletResponse response, ExportQuery query) {
        
        // 1. é¢„ä¼°æ•°æ®é‡ï¼Œé€‰æ‹©åˆé€‚çš„å¤„ç†æ–¹å¼
        long estimatedRows = dataService.countByQuery(query);
        
        if (estimatedRows > 10000) {
            // å¤§é‡æ•°æ®ä½¿ç”¨å¼‚æ­¥+åˆ†é¡µå¤„ç†
            exportLargeDataAsync(response, query, estimatedRows);
        } else {
            // å°é‡æ•°æ®ç›´æ¥å¯¼å‡º
            exportSmallData(response, query);
        }
    }
    
    private void exportLargeDataAsync(HttpServletResponse response, ExportQuery query, long totalRows) {
        
        try (OutputStream outputStream = response.getOutputStream()) {
            
            // è®¾ç½®å“åº”å¤´
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            response.setHeader("Content-Disposition", "attachment; filename=large_export.xlsx");
            
            // ä½¿ç”¨EasyExcelçš„writeæ–¹å¼ï¼Œæ”¯æŒå¤§æ•°æ®é‡
            ExcelWriter writer = EasyExcel.write(outputStream, User.class).build();
            WriteSheet writeSheet = EasyExcel.writerSheet("æ•°æ®").build();
            
            // åˆ†é¡µæŸ¥è¯¢å¹¶å†™å…¥
            int pageSize = 2000;
            int totalPages = (int) Math.ceil((double) totalRows / pageSize);
            
            for (int page = 0; page < totalPages; page++) {
                List<User> data = dataService.findByQueryPaged(query, page, pageSize);
                writer.write(data, writeSheet);
                
                // æ˜¾ç¤ºè¿›åº¦ï¼ˆå¯é€‰ï¼‰
                log.info("å¯¼å‡ºè¿›åº¦ï¼š{}/{}", page + 1, totalPages);
            }
            
            writer.finish();
            
        } catch (Exception e) {
            log.error("å¤§æ•°æ®é‡å¯¼å‡ºå¤±è´¥", e);
            throw new BusinessException("å¯¼å‡ºå¤±è´¥ï¼š" + e.getMessage());
        }
    }
    
    private void exportSmallData(HttpServletResponse response, ExportQuery query) {
        List<User> data = dataService.findByQuery(query);
        
        // è®¾ç½®å“åº”å¤´
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setHeader("Content-Disposition", "attachment; filename=export.xlsx");
        
        // ç›´æ¥å¯¼å‡º
        ExcelWriteResult result = excelService.write(response.getOutputStream(), data, User.class);
        
        if (!result.isSuccess()) {
            throw new BusinessException("å¯¼å‡ºå¤±è´¥ï¼š" + result.getErrorMessage());
        }
    }
}
```

### 5.3 æ•°æ®é—®é¢˜

#### Q6: å¦‚ä½•å¤„ç†æ—¥æœŸæ ¼å¼ä¸ç»Ÿä¸€çš„é—®é¢˜ï¼Ÿ

**A:** ä½¿ç”¨è‡ªå®šä¹‰æ—¥æœŸè½¬æ¢å™¨ï¼š

```java
@Component
public class FlexibleDateTimeConverter implements ExcelDataConverter<LocalDateTime> {
    
    private static final List<DateTimeFormatter> FORMATTERS = Arrays.asList(
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"),
        DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss"),
        DateTimeFormatter.ofPattern("yyyy-MM-dd"),
        DateTimeFormatter.ofPattern("yyyy/MM/dd"),
        DateTimeFormatter.ofPattern("MM/dd/yyyy"),
        DateTimeFormatter.ofPattern("dd/MM/yyyy")
    );
    
    @Override
    public LocalDateTime convertToJavaData(String cellValue, ExcelContentProperty contentProperty, 
                                          GlobalConfiguration globalConfiguration) {
        if (StringUtils.isBlank(cellValue)) {
            return null;
        }
        
        String cleanValue = cellValue.trim();
        
        // å°è¯•å¤šç§æ ¼å¼è§£æ
        for (DateTimeFormatter formatter : FORMATTERS) {
            try {
                if (formatter.toString().contains("HH:mm:ss")) {
                    return LocalDateTime.parse(cleanValue, formatter);
                } else {
                    return LocalDate.parse(cleanValue, formatter).atStartOfDay();
                }
            } catch (DateTimeParseException e) {
                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæ ¼å¼
            }
        }
        
        // å°è¯•è§£ææ—¶é—´æˆ³
        try {
            long timestamp = Long.parseLong(cleanValue);
            return LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());
        } catch (NumberFormatException e) {
            // å¿½ç•¥
        }
        
        throw new IllegalArgumentException("æ— æ³•è§£ææ—¥æœŸæ ¼å¼ï¼š" + cellValue);
    }
    
    @Override
    public String convertToExcelData(LocalDateTime value, ExcelContentProperty contentProperty, 
                                   GlobalConfiguration globalConfiguration) {
        return value != null ? value.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) : "";
    }
    
    @Override
    public Class<LocalDateTime> supportJavaTypeKey() {
        return LocalDateTime.class;
    }
}

// ä½¿ç”¨è½¬æ¢å™¨
public class FlexibleDateEntity {
    
    @ExcelField(value = "åˆ›å»ºæ—¶é—´", converter = FlexibleDateTimeConverter.class)
    private LocalDateTime createTime;
}
```

#### Q7: å¦‚ä½•å¤„ç†åŠ¨æ€åˆ—ï¼ˆåˆ—æ•°ä¸å›ºå®šï¼‰ï¼Ÿ

**A:** ä½¿ç”¨ Map æˆ–åŠ¨æ€å¯¹è±¡ï¼š

```java
// æ–¹å¼1ï¼šä½¿ç”¨Mapå¤„ç†åŠ¨æ€åˆ—
@Data
@ExcelSheet("åŠ¨æ€æ•°æ®")
public class DynamicData {
    
    @ExcelField(value = "ID", index = 0, required = true)
    private Long id;
    
    @ExcelField(value = "åç§°", index = 1, required = true)
    private String name;
    
    // ä½¿ç”¨Mapå­˜å‚¨åŠ¨æ€å­—æ®µ
    @ExcelField(ignore = true)
    private Map<String, Object> dynamicFields = new HashMap<>();
    
    // æä¾›ä¾¿æ·æ–¹æ³•
    public void setDynamicField(String key, Object value) {
        dynamicFields.put(key, value);
    }
    
    public Object getDynamicField(String key) {
        return dynamicFields.get(key);
    }
}

// æ–¹å¼2ï¼šä½¿ç”¨è‡ªå®šä¹‰ç›‘å¬å™¨å¤„ç†
@Component
public class DynamicColumnListener implements ReadListener<Map<Integer, String>> {
    
    private List<String> headers = new ArrayList<>();
    private List<Map<String, Object>> dataList = new ArrayList<>();
    
    @Override
    public void invokeHeadMap(Map<Integer, String> headMap, AnalysisContext context) {
        // åŠ¨æ€è·å–è¡¨å¤´
        headers = headMap.values().stream()
            .collect(Collectors.toList());
    }
    
    @Override
    public void invoke(Map<Integer, String> data, AnalysisContext context) {
        // å°†è¡Œæ•°æ®è½¬æ¢ä¸ºMap
        Map<String, Object> rowData = new HashMap<>();
        for (int i = 0; i < headers.size(); i++) {
            String header = headers.get(i);
            String value = data.get(i);
            rowData.put(header, value);
        }
        dataList.add(rowData);
    }
    
    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        log.info("åŠ¨æ€åˆ—è¯»å–å®Œæˆï¼Œå…±{}åˆ—ï¼Œ{}è¡Œæ•°æ®", headers.size(), dataList.size());
    }
    
    public List<Map<String, Object>> getDataList() {
        return dataList;
    }
}

// ä½¿ç”¨æœåŠ¡
@Service
public class DynamicColumnService {
    
    public List<Map<String, Object>> readDynamicColumns(String filePath) {
        DynamicColumnListener listener = new DynamicColumnListener();
        
        EasyExcel.read(filePath, listener).sheet().doRead();
        
        return listener.getDataList();
    }
}
```

### 5.4 é›†æˆé—®é¢˜

#### Q8: å¦‚ä½•ä¸ Spring Security é›†æˆï¼Ÿ

**A:** åœ¨æ§åˆ¶å™¨å±‚æ·»åŠ å®‰å…¨æ§åˆ¶ï¼š

```java
@RestController
@RequestMapping("/api/excel")
@PreAuthorize("hasRole('ADMIN')")  // éœ€è¦ADMINè§’è‰²
public class SecureExcelController {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    @PostMapping("/import")
    @PreAuthorize("hasAuthority('EXCEL_IMPORT')")  // éœ€è¦å¯¼å…¥æƒé™
    public ResponseEntity<?> importData(@RequestParam("file") MultipartFile file,
                                       Authentication authentication) {
        
        String operator = authentication.getName();
        
        try {
            // è®°å½•æ“ä½œæ—¥å¿—
            auditService.logImportOperation(operator, file.getOriginalFilename());
            
            ExcelReadResult<User> result = excelService.read(file.getInputStream(), User.class);
            
            if (result.isSuccess()) {
                // æ•°æ®éªŒè¯é€šè¿‡ï¼Œä¿å­˜æ•°æ®
                userService.batchSave(result.getData(), operator);
                
                return ResponseEntity.ok(ImportResponse.success()
                    .message("å¯¼å…¥æˆåŠŸ")
                    .total(result.getData().size())
                    .build());
            } else {
                return ResponseEntity.badRequest().body(ImportResponse.failure()
                    .message("æ•°æ®éªŒè¯å¤±è´¥")
                    .errors(result.getErrors())
                    .build());
            }
            
        } catch (Exception e) {
            log.error("ç”¨æˆ·{}å¯¼å…¥æ•°æ®å¤±è´¥", operator, e);
            return ResponseEntity.status(500).body(ImportResponse.error("ç³»ç»Ÿé”™è¯¯"));
        }
    }
    
    @GetMapping("/export")
    @PreAuthorize("hasAuthority('EXCEL_EXPORT')")  // éœ€è¦å¯¼å‡ºæƒé™
    public void exportData(HttpServletResponse response,
                          @RequestParam(required = false) String department,
                          Authentication authentication) {
        
        String operator = authentication.getName();
        
        try {
            // æ ¹æ®ç”¨æˆ·æƒé™è¿‡æ»¤æ•°æ®
            List<User> users = getUsersByPermission(operator, department);
            
            // è®°å½•æ“ä½œæ—¥å¿—
            auditService.logExportOperation(operator, users.size());
            
            // è®¾ç½®å“åº”å¤´
            String fileName = "ç”¨æˆ·æ•°æ®_" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")) + ".xlsx";
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            response.setHeader("Content-Disposition", "attachment; filename=" + URLEncoder.encode(fileName, "UTF-8"));
            
            excelService.write(response.getOutputStream(), users, User.class);
            
        } catch (Exception e) {
            log.error("ç”¨æˆ·{}å¯¼å‡ºæ•°æ®å¤±è´¥", operator, e);
            throw new BusinessException("å¯¼å‡ºå¤±è´¥ï¼š" + e.getMessage());
        }
    }
    
    private List<User> getUsersByPermission(String operator, String department) {
        // æ ¹æ®ç”¨æˆ·æƒé™å’Œéƒ¨é—¨è¿‡æ»¤æ•°æ®
        UserQueryDto query = new UserQueryDto();
        
        // å¦‚æœä¸æ˜¯è¶…çº§ç®¡ç†å‘˜ï¼Œåªèƒ½çœ‹åˆ°è‡ªå·±éƒ¨é—¨çš„æ•°æ®
        if (!hasRole(operator, "SUPER_ADMIN")) {
            String userDepartment = userService.getUserDepartment(operator);
            query.setDepartment(userDepartment);
        } else if (StringUtils.isNotBlank(department)) {
            query.setDepartment(department);
        }
        
        return userService.findByQuery(query);
    }
}
```

#### Q9: å¦‚ä½•è¿›è¡Œå•å…ƒæµ‹è¯•ï¼Ÿ

**A:** å®Œæ•´çš„æµ‹è¯•ç¤ºä¾‹ï¼š

```java
@ExtendWith(MockitoExtension.class)
class UserExcelServiceTest {
    
    @Mock
    private AnnotationExcelService excelService;
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserExcelService userExcelService;
    
    @Test
    @DisplayName("æ­£å¸¸å¯¼å…¥ç”¨æˆ·æ•°æ®")
    void testImportUsers_Success() {
        // Given
        MultipartFile file = createMockFile("users.xlsx");
        List<User> mockUsers = createTestUsers();
        ExcelReadResult<User> mockResult = ExcelReadResult.<User>builder()
            .success(true)
            .data(mockUsers)
            .totalRows(mockUsers.size())
            .build();
        
        when(excelService.read(any(InputStream.class), eq(User.class)))
            .thenReturn(mockResult);
        when(userRepository.saveAll(anyList()))
            .thenReturn(mockUsers);
        
        // When
        ImportResult result = userExcelService.importUsers(file, ImportOptions.defaultOptions());
        
        // Then
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getTotal()).isEqualTo(mockUsers.size());
        
        verify(excelService).read(any(InputStream.class), eq(User.class));
        verify(userRepository).saveAll(eq(mockUsers));
    }
    
    @Test
    @DisplayName("å¯¼å…¥åŒ…å«é”™è¯¯çš„æ•°æ®")
    void testImportUsers_WithErrors() {
        // Given
        MultipartFile file = createMockFile("users_with_errors.xlsx");
        List<ExcelError> errors = Arrays.asList(
            ExcelError.builder()
                .rowIndex(2)
                .errorMessage("é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")
                .build()
        );
        
        ExcelReadResult<User> mockResult = ExcelReadResult.<User>builder()
            .success(false)
            .errors(errors)
            .build();
        
        when(excelService.read(any(InputStream.class), eq(User.class)))
            .thenReturn(mockResult);
        
        // When
        ImportResult result = userExcelService.importUsers(file, ImportOptions.defaultOptions());
        
        // Then
        assertThat(result.isSuccess()).isFalse();
        assertThat(result.getErrors()).isNotEmpty();
        
        verify(userRepository, never()).saveAll(anyList());
    }
}
```

#### 6.4.2 é›†æˆæµ‹è¯•ç­–ç•¥

```java
@SpringBootTest
@TestPropertySource(properties = {
    "slavopolis.excel.validation.max-file-size=1048576",  // 1MB for testing
    "slavopolis.excel.async.enabled=false"  // ç¦ç”¨å¼‚æ­¥ï¼Œä¾¿äºæµ‹è¯•
})
class ExcelIntegrationTest {
    
    @Autowired
    private UserExcelService userExcelService;
    
    @Autowired
    private UserRepository userRepository;
    
    @TempDir
    Path tempDir;
    
    @Test
    @Transactional
    @Rollback
    void testCompleteImportFlow() throws IOException {
        // å‡†å¤‡æµ‹è¯•æ•°æ®æ–‡ä»¶
        Path testFile = createTestExcelFile();
        MockMultipartFile multipartFile = new MockMultipartFile(
            "file",
            "test.xlsx",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            Files.readAllBytes(testFile)
        );
        
        // æ‰§è¡Œå¯¼å…¥
        ImportResult result = userExcelService.importUsers(multipartFile, ImportOptions.defaultOptions());
        
        // éªŒè¯ç»“æœ
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getTotal()).isEqualTo(3);
        
        // éªŒè¯æ•°æ®åº“
        List<User> savedUsers = userRepository.findAll();
        assertThat(savedUsers).hasSize(3);
        assertThat(savedUsers.get(0).getUsername()).isEqualTo("å¼ ä¸‰");
    }
    
    private Path createTestExcelFile() throws IOException {
        Path filePath = tempDir.resolve("test.xlsx");
        
        List<User> testData = Arrays.asList(
            new User("å¼ ä¸‰", "zhangsan@test.com"),
            new User("æå››", "lisi@test.com"),
            new User("ç‹äº”", "wangwu@test.com")
        );
        
        EasyExcel.write(filePath.toString(), User.class)
            .sheet("ç”¨æˆ·æ•°æ®")
            .doWrite(testData);
        
        return filePath;
    }
}
```

### 6.5 ç›‘æ§å’Œè¿ç»´å®è·µ

#### 6.5.1 æ€§èƒ½ç›‘æ§

```java
@Component
public class ExcelPerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Timer importTimer;
    private final Counter importCounter;
    private final Gauge memoryGauge;
    
    public ExcelPerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.importTimer = Timer.builder("excel.import.duration")
            .description("Excelå¯¼å…¥è€—æ—¶")
            .register(meterRegistry);
        this.importCounter = Counter.builder("excel.import.count")
            .description("Excelå¯¼å…¥æ¬¡æ•°")
            .register(meterRegistry);
        this.memoryGauge = Gauge.builder("excel.memory.usage")
            .description("Excelå¤„ç†å†…å­˜ä½¿ç”¨")
            .register(meterRegistry, this, ExcelPerformanceMonitor::getMemoryUsage);
    }
    
    public <T> T monitorImport(String operation, Supplier<T> supplier) {
        return importTimer.recordCallable(() -> {
            importCounter.increment();
            return supplier.get();
        });
    }
    
    private double getMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        return (runtime.totalMemory() - runtime.freeMemory()) / (1024.0 * 1024.0); // MB
    }
}

// ä½¿ç”¨ç›‘æ§
@Service
public class MonitoredExcelService {
    
    @Autowired
    private ExcelPerformanceMonitor performanceMonitor;
    
    @Autowired
    private AnnotationExcelService excelService;
    
    public ImportResult importUsers(MultipartFile file) {
        return performanceMonitor.monitorImport("user_import", () -> {
            return excelService.read(file.getInputStream(), User.class);
        });
    }
}
```

#### 6.5.2 å¥åº·æ£€æŸ¥

```java
@Component
public class ExcelHealthIndicator implements HealthIndicator {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    @Autowired
    private ExcelProperties excelProperties;
    
    @Override
    public Health health() {
        try {
            // æ£€æŸ¥ExcelæœåŠ¡æ˜¯å¦å¯ç”¨
            if (!excelProperties.isEnabled()) {
                return Health.down()
                    .withDetail("reason", "ExcelåŠŸèƒ½å·²ç¦ç”¨")
                    .build();
            }
            
            // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
            double memoryUsage = getMemoryUsagePercentage();
            if (memoryUsage > 80) {
                return Health.down()
                    .withDetail("reason", "å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜")
                    .withDetail("memoryUsage", memoryUsage + "%")
                    .build();
            }
            
            // æ£€æŸ¥ä¸´æ—¶æ–‡ä»¶ç›®å½•
            if (!isTempDirectoryWritable()) {
                return Health.down()
                    .withDetail("reason", "ä¸´æ—¶ç›®å½•ä¸å¯å†™")
                    .build();
            }
            
            return Health.up()
                .withDetail("memoryUsage", memoryUsage + "%")
                .withDetail("tempDirectoryWritable", true)
                .build();
                
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
    
    private double getMemoryUsagePercentage() {
        Runtime runtime = Runtime.getRuntime();
        long maxMemory = runtime.maxMemory();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        return (double) usedMemory / maxMemory * 100;
    }
    
    private boolean isTempDirectoryWritable() {
        try {
            Path tempDir = Paths.get(System.getProperty("java.io.tmpdir"));
            Path testFile = tempDir.resolve("excel_health_check.tmp");
            Files.write(testFile, "test".getBytes());
            Files.delete(testFile);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

## 6. æœ€ä½³å®è·µæŒ‡å—

### 6.1 è®¾è®¡åŸåˆ™

#### 6.1.1 å®ä½“ç±»è®¾è®¡

**âœ… æ¨èåšæ³•**:

```java
@Data
@ExcelSheet(value = "ç”¨æˆ·ä¿¡æ¯", description = "ç”¨æˆ·åŸºæœ¬ä¿¡æ¯å¯¼å…¥è¡¨")
public class User {
    
    // ä½¿ç”¨å…·ä½“çš„æ•°æ®ç±»å‹ï¼Œé¿å…ä½¿ç”¨Object
    @ExcelField(value = "ç”¨æˆ·ID", index = 0, required = true)
    private Long id;
    
    // æä¾›è¯¦ç»†çš„éªŒè¯è§„åˆ™
    @ExcelField(value = "ç”¨æˆ·å", index = 1, required = true, maxLength = 50, 
                message = "ç”¨æˆ·åé•¿åº¦ä¸èƒ½è¶…è¿‡50ä¸ªå­—ç¬¦")
    private String username;
    
    // ä½¿ç”¨åˆé€‚çš„æ—¥æœŸç±»å‹å’Œæ ¼å¼
    @ExcelField(value = "åˆ›å»ºæ—¶é—´", index = 2, dateFormat = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createTime;
    
    // æšä¸¾ç±»å‹ä½¿ç”¨è‡ªå®šä¹‰è½¬æ¢å™¨
    @ExcelField(value = "çŠ¶æ€", index = 3, converter = UserStatusConverter.class)
    private UserStatus status;
    
    // æ„é€ å‡½æ•°å’Œå¿…è¦çš„ä¸šåŠ¡æ–¹æ³•
    public User() {}
    
    public User(String username, UserStatus status) {
        this.username = username;
        this.status = status;
        this.createTime = LocalDateTime.now();
    }
    
    // ä¸šåŠ¡éªŒè¯æ–¹æ³•
    public boolean isValid() {
        return StringUtils.isNotBlank(username) && status != null;
    }
}
```

**âŒ é¿å…çš„åšæ³•**:

```java
// ä¸æ¨èï¼šå­—æ®µç±»å‹ä¸æ˜ç¡®ï¼Œç¼ºå°‘éªŒè¯
@Data
@ExcelSheet("ç”¨æˆ·")
public class BadUser {
    
    @ExcelField("ID")
    private Object id;  // âŒ ä½¿ç”¨Objectç±»å‹
    
    @ExcelField("åç§°")
    private String name;  // âŒ ç¼ºå°‘éªŒè¯è§„åˆ™
    
    @ExcelField("æ—¶é—´")
    private String time;  // âŒ æ—¶é—´ç”¨Stringå­˜å‚¨
    
    @ExcelField("çŠ¶æ€")
    private String status;  // âŒ æšä¸¾ç”¨Stringå­˜å‚¨
}
```

#### 6.1.2 æœåŠ¡å±‚è®¾è®¡

**æœ€ä½³å®è·µæ¨¡å¼**:

```java
@Service
@Transactional
public class UserExcelService {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private UserValidator userValidator;
    
    /**
     * å¯¼å…¥ç”¨æˆ·æ•°æ® - å®Œæ•´çš„ä¸šåŠ¡æµç¨‹
     */
    public ImportResult importUsers(MultipartFile file, ImportOptions options) {
        
        // 1. å‰ç½®éªŒè¯
        ValidationResult validation = validateImportFile(file);
        if (!validation.isValid()) {
            return ImportResult.failure(validation.getErrorMessage());
        }
        
        try {
            // 2. è¯»å–Excelæ•°æ®
            ExcelReadResult<User> readResult = excelService.read(file.getInputStream(), User.class);
            
            if (!readResult.isSuccess()) {
                return handleReadErrors(readResult);
            }
            
            // 3. ä¸šåŠ¡éªŒè¯
            List<User> validUsers = new ArrayList<>();
            List<ImportError> businessErrors = new ArrayList<>();
            
            for (int i = 0; i < readResult.getData().size(); i++) {
                User user = readResult.getData().get(i);
                
                ValidationResult userValidation = userValidator.validate(user);
                if (userValidation.isValid()) {
                    validUsers.add(user);
                } else {
                    businessErrors.add(new ImportError(i + 2, userValidation.getErrorMessage()));
                }
            }
            
            // 4. æ•°æ®å¤„ç†é€‰é¡¹
            if (options.isSkipErrors() && !businessErrors.isEmpty()) {
                // è·³è¿‡é”™è¯¯æ•°æ®ï¼Œå¤„ç†æœ‰æ•ˆæ•°æ®
                return processValidUsers(validUsers, businessErrors, options);
            } else if (!businessErrors.isEmpty()) {
                // å­˜åœ¨é”™è¯¯ï¼Œä¸å¤„ç†ä»»ä½•æ•°æ®
                return ImportResult.failure("æ•°æ®éªŒè¯å¤±è´¥").errors(businessErrors);
            }
            
            // 5. ä¿å­˜æ•°æ®
            return saveUsers(validUsers, options);
            
        } catch (Exception e) {
            log.error("å¯¼å…¥ç”¨æˆ·æ•°æ®å¤±è´¥", e);
            return ImportResult.error("ç³»ç»Ÿé”™è¯¯ï¼š" + e.getMessage());
        }
    }
    
    private ValidationResult validateImportFile(MultipartFile file) {
        // æ–‡ä»¶æ ¼å¼ã€å¤§å°ã€å†…å®¹éªŒè¯
        return fileValidator.validate(file);
    }
    
    private ImportResult handleReadErrors(ExcelReadResult<User> readResult) {
        // å°†Excelè¯»å–é”™è¯¯è½¬æ¢ä¸ºä¸šåŠ¡é”™è¯¯
        List<ImportError> errors = readResult.getErrors().stream()
            .map(this::convertToImportError)
            .collect(Collectors.toList());
        
        return ImportResult.failure("Excelæ ¼å¼é”™è¯¯").errors(errors);
    }
    
    @Transactional(rollbackFor = Exception.class)
    private ImportResult saveUsers(List<User> users, ImportOptions options) {
        if (options.isBatchMode()) {
            // æ‰¹é‡ä¿å­˜
            userRepository.saveAll(users);
        } else {
            // é€æ¡ä¿å­˜ï¼Œä¾¿äºé”™è¯¯å®šä½
            for (User user : users) {
                userRepository.save(user);
            }
        }
        
        return ImportResult.success()
            .message(String.format("æˆåŠŸå¯¼å…¥%dæ¡ç”¨æˆ·æ•°æ®", users.size()))
            .total(users.size());
    }
}
```

### 6.2 æ€§èƒ½ä¼˜åŒ–å®è·µ

#### 6.2.1 å†…å­˜ä¼˜åŒ–ç­–ç•¥

```java
@Service
public class MemoryOptimizedExcelService {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    /**
     * å†…å­˜å‹å¥½çš„å¤§æ–‡ä»¶å¤„ç†
     */
    public void processLargeFileMemoryFriendly(String filePath) {
        
        // ç­–ç•¥1ï¼šæµå¼å¤„ç†ï¼Œé¿å…å…¨é‡åŠ è½½
        processWithStreaming(filePath);
        
        // ç­–ç•¥2ï¼šåˆ†æ‰¹å¤„ç†
        processWithBatching(filePath);
        
        // ç­–ç•¥3ï¼šå¼‚æ­¥å¤„ç†
        processWithAsync(filePath);
    }
    
    private void processWithStreaming(String filePath) {
        ExcelReadRequest<User> request = ExcelReadRequest.<User>builder()
            .filePath(filePath)
            .dataClass(User.class)
            .config(ReadConfig.builder()
                .enableStreamProcessing(true)
                .batchSize(500)  // å°æ‰¹æ¬¡å¤„ç†
                .build())
            .build();
        
        excelService.readStream(request, user -> {
            // é€æ¡å¤„ç†ï¼ŒåŠæ—¶é‡Šæ”¾å†…å­˜
            processUserImmediately(user);
        });
    }
    
    private void processWithBatching(String filePath) {
        int pageSize = 1000;
        int pageIndex = 0;
        
        while (true) {
            List<User> batch = readBatch(filePath, pageIndex, pageSize);
            if (batch.isEmpty()) {
                break;
            }
            
            // å¤„ç†å½“å‰æ‰¹æ¬¡
            processBatch(batch);
            
            // æ‰‹åŠ¨è§¦å‘GCï¼ˆå¯é€‰ï¼‰
            if (pageIndex % 10 == 0) {
                System.gc();
            }
            
            pageIndex++;
        }
    }
    
    private CompletableFuture<Void> processWithAsync(String filePath) {
        return excelService.readAsync(filePath, User.class)
            .thenAccept(result -> {
                if (result.isSuccess()) {
                    // å¼‚æ­¥å¤„ç†ç»“æœ
                    processUsersAsync(result.getData());
                }
            })
            .exceptionally(throwable -> {
                log.error("å¼‚æ­¥å¤„ç†å¤±è´¥", throwable);
                return null;
            });
    }
}
```

#### 6.2.2 æ•°æ®åº“æ“ä½œä¼˜åŒ–

```java
@Service
public class DatabaseOptimizedService {
    
    @Autowired
    private UserRepository userRepository;
    
    /**
     * ä¼˜åŒ–çš„æ‰¹é‡ä¿å­˜
     */
    @Transactional
    public void optimizedBatchSave(List<User> users) {
        
        // ç­–ç•¥1ï¼šä½¿ç”¨Spring Data JPAçš„æ‰¹é‡æ“ä½œ
        int batchSize = 1000;
        for (int i = 0; i < users.size(); i += batchSize) {
            int end = Math.min(i + batchSize, users.size());
            List<User> batch = users.subList(i, end);
            
            userRepository.saveAll(batch);
            userRepository.flush();  // å¼ºåˆ¶åˆ·æ–°åˆ°æ•°æ®åº“
        }
        
        // ç­–ç•¥2ï¼šä½¿ç”¨JdbcTemplateçš„æ‰¹é‡æ’å…¥
        batchInsertWithJdbc(users);
        
        // ç­–ç•¥3ï¼šä½¿ç”¨MyBatisçš„æ‰¹é‡æ“ä½œ
        batchInsertWithMyBatis(users);
    }
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    private void batchInsertWithJdbc(List<User> users) {
        String sql = "INSERT INTO users (username, email, create_time, status) VALUES (?, ?, ?, ?)";
        
        jdbcTemplate.batchUpdate(sql, users, 1000, (ps, user) -> {
            ps.setString(1, user.getUsername());
            ps.setString(2, user.getEmail());
            ps.setTimestamp(3, Timestamp.valueOf(user.getCreateTime()));
            ps.setString(4, user.getStatus().name());
        });
    }
    
    @Autowired
    private SqlSession sqlSession;
    
    private void batchInsertWithMyBatis(List<User> users) {
        try (SqlSession batchSqlSession = sqlSession.getSqlSessionFactory().openSession(ExecutorType.BATCH)) {
            UserMapper mapper = batchSqlSession.getMapper(UserMapper.class);
            
            for (User user : users) {
                mapper.insert(user);
            }
            
            batchSqlSession.commit();
        }
    }
}
```

### 6.3 é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

#### 6.3.1 åˆ†å±‚é”™è¯¯å¤„ç†

```java
// 1. ä¸šåŠ¡å¼‚å¸¸å®šä¹‰
public class ExcelBusinessException extends ExcelException {
    
    private final List<BusinessError> businessErrors;
    
    public ExcelBusinessException(String message, List<BusinessError> businessErrors) {
        super(ExcelErrorCode.BUSINESS_VALIDATION_FAILED, message);
        this.businessErrors = businessErrors;
    }
    
    public List<BusinessError> getBusinessErrors() {
        return businessErrors;
    }
}

// 2. å…¨å±€å¼‚å¸¸å¤„ç†å™¨
@ControllerAdvice
public class ExcelExceptionHandler {
    
    @ExceptionHandler(ExcelBusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(ExcelBusinessException e) {
        ErrorResponse response = ErrorResponse.builder()
            .code(e.getErrorCode().getCode())
            .message(e.getMessage())
            .businessErrors(e.getBusinessErrors())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.badRequest().body(response);
    }
    
    @ExceptionHandler(ExcelException.class)
    public ResponseEntity<ErrorResponse> handleExcelException(ExcelException e) {
        ErrorResponse response = ErrorResponse.builder()
            .code(e.getErrorCode().getCode())
            .message(e.getMessage())
            .context(e.getContext())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(500).body(response);
    }
}

// 3. å‹å¥½çš„é”™è¯¯å“åº”
@Data
@Builder
public class ErrorResponse {
    private String code;
    private String message;
    private List<BusinessError> businessErrors;
    private Map<String, Object> context;
    private LocalDateTime timestamp;
}
```

#### 6.3.2 é”™è¯¯æ¢å¤ç­–ç•¥

```java
@Service
public class ErrorRecoveryService {
    
    /**
     * æ”¯æŒé”™è¯¯æ¢å¤çš„å¯¼å…¥æµç¨‹
     */
    public ImportResult importWithRecovery(MultipartFile file, RecoveryOptions options) {
        
        try {
            // ç¬¬ä¸€æ¬¡å°è¯•ï¼šæ­£å¸¸å¯¼å…¥
            ImportResult result = normalImport(file);
            
            if (result.isSuccess()) {
                return result;
            }
            
            // ç¬¬äºŒæ¬¡å°è¯•ï¼šå®¹é”™æ¨¡å¼å¯¼å…¥
            if (options.isEnableRecovery()) {
                return recoveryImport(file, result.getErrors());
            }
            
            return result;
            
        } catch (Exception e) {
            log.error("å¯¼å…¥è¿‡ç¨‹å‘ç”Ÿå¼‚å¸¸", e);
            
            // æœ€åå°è¯•ï¼šåŸºç¡€æ¨¡å¼å¯¼å…¥
            if (options.isEnableBasicMode()) {
                return basicModeImport(file);
            }
            
            throw e;
        }
    }
    
    private ImportResult recoveryImport(MultipartFile file, List<ImportError> previousErrors) {
        
        // åˆ†æä¹‹å‰çš„é”™è¯¯ï¼Œè°ƒæ•´å¤„ç†ç­–ç•¥
        RecoveryStrategy strategy = analyzeErrors(previousErrors);
        
        // ä½¿ç”¨è°ƒæ•´åçš„é…ç½®é‡æ–°å¯¼å…¥
        ExcelReadConfig config = buildRecoveryConfig(strategy);
        
        return executeImportWithConfig(file, config);
    }
    
    private RecoveryStrategy analyzeErrors(List<ImportError> errors) {
        RecoveryStrategy strategy = new RecoveryStrategy();
        
        // åˆ†æé”™è¯¯ç±»å‹ï¼Œåˆ¶å®šæ¢å¤ç­–ç•¥
        for (ImportError error : errors) {
            if (error.getErrorType() == ErrorType.DATE_FORMAT) {
                strategy.enableFlexibleDateParsing();
            } else if (error.getErrorType() == ErrorType.NUMBER_FORMAT) {
                strategy.enableFlexibleNumberParsing();
            } else if (error.getErrorType() == ErrorType.VALIDATION) {
                strategy.enableValidationSkip();
            }
        }
        
        return strategy;
    }
}
```

### 6.4 æµ‹è¯•æœ€ä½³å®è·µ

#### 6.4.1 å•å…ƒæµ‹è¯•ç­–ç•¥

```java
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class ExcelServiceTest {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    @TempDir
    Path tempDir;
    
    @Test
    @Order(1)
    void testReadExcel() throws IOException {
        // å‡†å¤‡æµ‹è¯•æ•°æ®æ–‡ä»¶
        String testFilePath = createTestFile();
        
        // æ‰§è¡Œè¯»å–
        ExcelReadResult<User> result = excelService.read(testFilePath, User.class);
        
        // éªŒè¯ç»“æœ
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData()).hasSize(3);
        assertThat(result.getErrors()).isEmpty();
        
        User firstUser = result.getData().get(0);
        assertThat(firstUser.getId()).isEqualTo(1L);
        assertThat(firstUser.getName()).isEqualTo("å¼ ä¸‰");
    }
    
    @Test
    @Order(2)
    void testWriteExcel() throws IOException {
        // å‡†å¤‡æµ‹è¯•æ•°æ®
        List<User> users = createTestUsers();
        
        // æ‰§è¡Œå†™å…¥
        String outputPath = tempDir.resolve("output.xlsx").toString();
        ExcelWriteResult result = excelService.write(outputPath, users, User.class);
        
        // éªŒè¯ç»“æœ
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getWrittenRows()).isEqualTo(3);
        assertThat(Paths.get(outputPath)).exists();
    }
    
    @Test
    @Order(3)
    void testReadWithErrors() throws IOException {
        // å‡†å¤‡åŒ…å«é”™è¯¯çš„æµ‹è¯•æ–‡ä»¶
        String errorFilePath = createErrorTestFile();
        
        // æ‰§è¡Œè¯»å–
        ExcelReadResult<User> result = excelService.read(errorFilePath, User.class);
        
        // éªŒè¯ç»“æœ
        assertThat(result.isSuccess()).isFalse();
        assertThat(result.hasErrors()).isTrue();
        assertThat(result.getErrors()).hasSize(2);
        
        ExcelError firstError = result.getErrors().get(0);
        assertThat(firstError.getRowIndex()).isEqualTo(2);
        assertThat(firstError.getErrorMessage()).contains("é‚®ç®±æ ¼å¼ä¸æ­£ç¡®");
    }
    
    @Test
    @Order(4)
    void testAsyncOperation() throws Exception {
        // å‡†å¤‡å¤§æ–‡ä»¶
        String largeFilePath = createLargeTestFile(5000);
        
        // æ‰§è¡Œå¼‚æ­¥è¯»å–
        CompletableFuture<ExcelReadResult<User>> future = excelService.readAsync(largeFilePath, User.class);
        
        // ç­‰å¾…å®Œæˆ
        ExcelReadResult<User> result = future.get(30, TimeUnit.SECONDS);
        
        // éªŒè¯ç»“æœ
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData()).hasSize(5000);
    }
    
    private String createTestFile() throws IOException {
        Path filePath = tempDir.resolve("test.xlsx");
        
        List<User> testData = createTestUsers();
        
        // ä½¿ç”¨EasyExcelåˆ›å»ºæµ‹è¯•æ–‡ä»¶
        EasyExcel.write(filePath.toString(), User.class)
            .sheet("æµ‹è¯•æ•°æ®")
            .doWrite(testData);
            
        return filePath.toString();
    }
    
    private List<User> createTestUsers() {
        return Arrays.asList(
            new User(1L, "å¼ ä¸‰", "zhangsan@test.com", LocalDateTime.now(), UserStatus.NORMAL),
            new User(2L, "æå››", "lisi@test.com", LocalDateTime.now(), UserStatus.NORMAL),
            new User(3L, "ç‹äº”", "wangwu@test.com", LocalDateTime.now(), UserStatus.NORMAL)
        );
    }
}
```

#### 6.4.2 é›†æˆæµ‹è¯•ç­–ç•¥

```java
@SpringBootTest
@TestPropertySource(properties = {
    "slavopolis.excel.validation.max-file-size=1048576",  // 1MB for testing
    "slavopolis.excel.async.enabled=false"  // ç¦ç”¨å¼‚æ­¥ï¼Œä¾¿äºæµ‹è¯•
})
class ExcelIntegrationTest {
    
    @Autowired
    private UserExcelService userExcelService;
    
    @Autowired
    private UserRepository userRepository;
    
    @TempDir
    Path tempDir;
    
    @Test
    @Transactional
    @Rollback
    void testCompleteImportFlow() throws IOException {
        // å‡†å¤‡æµ‹è¯•æ•°æ®æ–‡ä»¶
        Path testFile = createTestExcelFile();
        MockMultipartFile multipartFile = new MockMultipartFile(
            "file",
            "test.xlsx",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            Files.readAllBytes(testFile)
        );
        
        // æ‰§è¡Œå¯¼å…¥
        ImportResult result = userExcelService.importUsers(multipartFile, ImportOptions.defaultOptions());
        
        // éªŒè¯ç»“æœ
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getTotal()).isEqualTo(3);
        
        // éªŒè¯æ•°æ®åº“
        List<User> savedUsers = userRepository.findAll();
        assertThat(savedUsers).hasSize(3);
        assertThat(savedUsers.get(0).getUsername()).isEqualTo("å¼ ä¸‰");
    }
    
    private Path createTestExcelFile() throws IOException {
        Path filePath = tempDir.resolve("test.xlsx");
        
        List<User> testData = Arrays.asList(
            new User(1L, "å¼ ä¸‰", "zhangsan@test.com", LocalDateTime.now(), UserStatus.NORMAL),
            new User(2L, "æå››", "lisi@test.com", LocalDateTime.now(), UserStatus.NORMAL),
            new User(3L, "ç‹äº”", "wangwu@test.com", LocalDateTime.now(), UserStatus.NORMAL)
        );
        
        EasyExcel.write(filePath.toString(), User.class)
            .sheet("æµ‹è¯•æ•°æ®")
            .doWrite(testData);
        
        return filePath;
    }
}
```

### 6.5 ç›‘æ§å’Œè¿ç»´å®è·µ

#### 6.5.1 æ€§èƒ½ç›‘æ§

```java
@Component
public class ExcelPerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Timer importTimer;
    private final Counter importCounter;
    private final Gauge memoryGauge;
    
    public ExcelPerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.importTimer = Timer.builder("excel.import.duration")
            .description("Excelå¯¼å…¥è€—æ—¶")
            .register(meterRegistry);
        this.importCounter = Counter.builder("excel.import.count")
            .description("Excelå¯¼å…¥æ¬¡æ•°")
            .register(meterRegistry);
        this.memoryGauge = Gauge.builder("excel.memory.usage")
            .description("Excelå¤„ç†å†…å­˜ä½¿ç”¨")
            .register(meterRegistry, this, ExcelPerformanceMonitor::getMemoryUsage);
    }
    
    public <T> T monitorImport(String operation, Supplier<T> supplier) {
        return importTimer.recordCallable(() -> {
            importCounter.increment();
            return supplier.get();
        });
    }
    
    private double getMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        return (runtime.totalMemory() - runtime.freeMemory()) / (1024.0 * 1024.0); // MB
    }
}

// ä½¿ç”¨ç›‘æ§
@Service
public class MonitoredExcelService {
    
    @Autowired
    private ExcelPerformanceMonitor performanceMonitor;
    
    @Autowired
    private AnnotationExcelService excelService;
    
    public ImportResult importUsers(MultipartFile file) {
        return performanceMonitor.monitorImport("user_import", () -> {
            return excelService.read(file.getInputStream(), User.class);
        });
    }
}
```

#### 6.5.2 å¥åº·æ£€æŸ¥

```java
@Component
public class ExcelHealthIndicator implements HealthIndicator {
    
    @Autowired
    private AnnotationExcelService excelService;
    
    @Autowired
    private ExcelProperties excelProperties;
    
    @Override
    public Health health() {
        try {
            // æ£€æŸ¥ExcelæœåŠ¡æ˜¯å¦å¯ç”¨
            if (!excelProperties.isEnabled()) {
                return Health.down()
                    .withDetail("reason", "ExcelåŠŸèƒ½å·²ç¦ç”¨")
                    .build();
            }
            
            // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
            double memoryUsage = getMemoryUsagePercentage();
            if (memoryUsage > 80) {
                return Health.down()
                    .withDetail("reason", "å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜")
                    .withDetail("memoryUsage", memoryUsage + "%")
                    .build();
            }
            
            // æ£€æŸ¥ä¸´æ—¶æ–‡ä»¶ç›®å½•
            if (!isTempDirectoryWritable()) {
                return Health.down()
                    .withDetail("reason", "ä¸´æ—¶ç›®å½•ä¸å¯å†™")
                    .build();
            }
            
            return Health.up()
                .withDetail("memoryUsage", memoryUsage + "%")
                .withDetail("tempDirectoryWritable", true)
                .build();
                
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
    
    private double getMemoryUsagePercentage() {
        Runtime runtime = Runtime.getRuntime();
        long maxMemory = runtime.maxMemory();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        return (double) usedMemory / maxMemory * 100;
    }
    
    private boolean isTempDirectoryWritable() {
        try {
            Path tempDir = Paths.get(System.getProperty("java.io.tmpdir"));
            Path testFile = tempDir.resolve("excel_health_check.tmp");
            Files.write(testFile, "test".getBytes());
            Files.delete(testFile);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

## 7. æ€§èƒ½è°ƒä¼˜å»ºè®®

### 7.1 JVM è°ƒä¼˜

#### 7.1.1 å†…å­˜é…ç½®

```bash
# ç”Ÿäº§ç¯å¢ƒæ¨èJVMå‚æ•°
-Xms2g                    # åˆå§‹å †å†…å­˜2GB
-Xmx4g                    # æœ€å¤§å †å†…å­˜4GB
-XX:NewRatio=3            # å¹´è½»ä»£ä¸è€å¹´ä»£æ¯”ä¾‹1:3
-XX:SurvivorRatio=8       # Edenä¸Survivoræ¯”ä¾‹8:1:1
-XX:MetaspaceSize=256m    # å…ƒç©ºé—´åˆå§‹å¤§å°
-XX:MaxMetaspaceSize=512m # å…ƒç©ºé—´æœ€å¤§å¤§å°

# GCè°ƒä¼˜å‚æ•°
-XX:+UseG1GC              # ä½¿ç”¨G1åƒåœ¾æ”¶é›†å™¨
-XX:MaxGCPauseMillis=200  # æœ€å¤§GCæš‚åœæ—¶é—´200ms
-XX:G1HeapRegionSize=16m  # G1åŒºåŸŸå¤§å°16MB
-XX:+G1UseAdaptiveIHOP    # è‡ªé€‚åº”IHOP

# å¤§æ–‡ä»¶å¤„ç†ä¸“ç”¨å‚æ•°
-XX:+UseLargePages        # ä½¿ç”¨å¤§é¡µå†…å­˜
-XX:LargePageSizeInBytes=2m # å¤§é¡µå¤§å°2MB
```

#### 7.1.2 GC ç›‘æ§é…ç½®

```bash
# GCæ—¥å¿—é…ç½®
-Xlog:gc*:gc.log:time,tags
-XX:+UseStringDeduplication
-XX:+PrintGCApplicationStoppedTime

# OOMæ—¶è‡ªåŠ¨dump
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/app/logs/heapdump/
```

### 7.2 åº”ç”¨å±‚é¢è°ƒä¼˜

#### 7.2.1 è¿æ¥æ± ä¼˜åŒ–

```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20          # æœ€å¤§è¿æ¥æ•°
      minimum-idle: 5                # æœ€å°ç©ºé—²è¿æ¥
      connection-timeout: 30000      # è¿æ¥è¶…æ—¶30ç§’
      idle-timeout: 600000           # ç©ºé—²è¶…æ—¶10åˆ†é’Ÿ
      max-lifetime: 1800000          # è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ30åˆ†é’Ÿ
      leak-detection-threshold: 60000 # è¿æ¥æ³„æ¼æ£€æµ‹é˜ˆå€¼1åˆ†é’Ÿ

slavopolis:
  excel:
    async:
      thread-pool:
        core-size: 8                 # æ ¸å¿ƒçº¿ç¨‹æ•°=CPUæ ¸æ•°
        max-size: 16                 # æœ€å¤§çº¿ç¨‹æ•°=CPUæ ¸æ•°*2
        queue-capacity: 200          # é˜Ÿåˆ—å®¹é‡
        keep-alive: 60               # ç©ºé—²ä¿æ´»æ—¶é—´
    performance:
      default-batch-size: 2000      # æ‰¹å¤„ç†å¤§å°
      memory-threshold: 10000       # å†…å­˜é˜ˆå€¼
```

#### 7.2.2 ç¼“å­˜ä¼˜åŒ–é…ç½®

```java
@Configuration
@EnableCaching
public class CacheConfiguration {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)                    // æœ€å¤§ç¼“å­˜æ¡ç›®æ•°
            .expireAfterWrite(30, TimeUnit.MINUTES) // å†™å…¥å30åˆ†é’Ÿè¿‡æœŸ
            .expireAfterAccess(15, TimeUnit.MINUTES) // è®¿é—®å15åˆ†é’Ÿè¿‡æœŸ
            .recordStats());                      // å¯ç”¨ç»Ÿè®¡
        return cacheManager;
    }
    
    @Bean
    public CacheMetricsRegistrar cacheMetricsRegistrar() {
        return new CacheMetricsRegistrar();
    }
}
```

### 7.3 å¤§æ–‡ä»¶å¤„ç†ä¼˜åŒ–

#### 7.3.1 åˆ†ç‰‡å¤„ç†ç­–ç•¥

```java
@Service
public class LargeFileOptimizedService {
    
    private static final int CHUNK_SIZE = 10000; // æ¯ç‰‡10000è¡Œ
    
    public void processLargeFileOptimized(String filePath) {
        
        // 1. è·å–æ–‡ä»¶æ€»è¡Œæ•°
        long totalRows = estimateFileRows(filePath);
        
        if (totalRows > 50000) {
            // è¶…å¤§æ–‡ä»¶ï¼šåˆ†ç‰‡+å¹¶è¡Œå¤„ç†
            processWithChunking(filePath, totalRows);
        } else if (totalRows > 10000) {
            // å¤§æ–‡ä»¶ï¼šæµå¼å¤„ç†
            processWithStreaming(filePath);
        } else {
            // æ™®é€šæ–‡ä»¶ï¼šæ ‡å‡†å¤„ç†
            processNormally(filePath);
        }
    }
    
    private void processWithChunking(String filePath, long totalRows) {
        int totalChunks = (int) Math.ceil((double) totalRows / CHUNK_SIZE);
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (int chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
            final int chunk = chunkIndex;
            
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                processChunk(filePath, chunk, CHUNK_SIZE);
            }, getOptimizedExecutor());
            
            futures.add(future);
        }
        
        // ç­‰å¾…æ‰€æœ‰åˆ†ç‰‡å¤„ç†å®Œæˆ
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    }
    
    private ThreadPoolExecutor getOptimizedExecutor() {
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        int maximumPoolSize = corePoolSize * 2;
        
        return new ThreadPoolExecutor(
            corePoolSize,
            maximumPoolSize,
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(100),
            new ThreadFactoryBuilder()
                .setNameFormat("excel-chunk-processor-%d")
                .setDaemon(true)
                .build(),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
}
```

## 8. æ•…éšœæ’æŸ¥æ‰‹å†Œ

### 8.1 å¸¸è§å¼‚å¸¸è¯Šæ–­

#### 8.1.1 å†…å­˜ç›¸å…³å¼‚å¸¸

**å¼‚å¸¸ä¿¡æ¯**: `OutOfMemoryError: Java heap space`

**æ’æŸ¥æ­¥éª¤**:

```bash
# 1. æŸ¥çœ‹å†…å­˜ä½¿ç”¨æƒ…å†µ
jstat -gc <pid> 250 4

# 2. åˆ†æå †å†…å­˜åˆ†å¸ƒ
jmap -histo <pid> | head -20

# 3. ç”Ÿæˆå †è½¬å‚¨æ–‡ä»¶
jmap -dump:format=b,file=heapdump.hprof <pid>

# 4. ä½¿ç”¨MATåˆ†æå †è½¬å‚¨
# ä¸‹è½½Eclipse MATå·¥å…·åˆ†æheapdump.hprofæ–‡ä»¶
```

**è§£å†³æ–¹æ¡ˆ**:

```java
// ä»£ç å±‚é¢ä¼˜åŒ–
@Service
public class MemoryOptimizedService {
    
    public void processLargeFileWithMemoryOptimization(String filePath) {
        
        // ä½¿ç”¨æµå¼å¤„ç†ï¼Œé¿å…å…¨é‡åŠ è½½
        ExcelReadConfig config = ExcelReadConfig.builder()
            .enableStreamProcessing(true)
            .batchSize(500)  // å‡å°æ‰¹æ¬¡å¤§å°
            .enableGCOptimization(true)  // å¯ç”¨GCä¼˜åŒ–
            .build();
            
        processWithConfig(filePath, config);
    }
    
    private void processWithConfig(String filePath, ExcelReadConfig config) {
        // å®šæœŸè§¦å‘GCï¼ˆä»…åœ¨å¿…è¦æ—¶ï¼‰
        int processedCount = 0;
        
        // ... å¤„ç†é€»è¾‘
        
        if (processedCount % 5000 == 0) {
            System.gc(); // å»ºè®®JVMè¿›è¡Œåƒåœ¾å›æ”¶
            try {
                Thread.sleep(100); // ç»™GCä¸€äº›æ—¶é—´
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

#### 8.1.2 æ–‡ä»¶å¤„ç†å¼‚å¸¸

**å¼‚å¸¸ä¿¡æ¯**: `IOException: Too many open files`

**æ’æŸ¥æ­¥éª¤**:

```bash
# 1. æŸ¥çœ‹è¿›ç¨‹æ‰“å¼€çš„æ–‡ä»¶æ•°
lsof -p <pid> | wc -l

# 2. æŸ¥çœ‹ç³»ç»Ÿé™åˆ¶
ulimit -n

# 3. æŸ¥çœ‹å…·ä½“æ‰“å¼€çš„æ–‡ä»¶
lsof -p <pid> | grep xlsx
```

**è§£å†³æ–¹æ¡ˆ**:

```java
@Component
public class FileResourceManager {
    
    private final AtomicInteger openFileCount = new AtomicInteger(0);
    private static final int MAX_OPEN_FILES = 500;
    
    public <T> T processFileWithResourceManagement(String filePath, Function<InputStream, T> processor) {
        
        if (openFileCount.get() >= MAX_OPEN_FILES) {
            throw new ResourceExhaustedException("æ‰“å¼€æ–‡ä»¶æ•°é‡è¶…è¿‡é™åˆ¶: " + MAX_OPEN_FILES);
        }
        
        openFileCount.incrementAndGet();
        
        try (InputStream inputStream = Files.newInputStream(Paths.get(filePath))) {
            return processor.apply(inputStream);
        } catch (IOException e) {
            throw new FileProcessingException("æ–‡ä»¶å¤„ç†å¤±è´¥: " + filePath, e);
        } finally {
            openFileCount.decrementAndGet();
        }
    }
}
```

### 8.2 æ€§èƒ½é—®é¢˜è¯Šæ–­

#### 8.2.1 æ…¢æŸ¥è¯¢åˆ†æ

```java
@Component
public class PerformanceDiagnostics {
    
    private static final Logger PERF_LOGGER = LoggerFactory.getLogger("PERFORMANCE");
    
    @EventListener
    public void handleSlowOperation(SlowOperationEvent event) {
        
        if (event.getDuration() > Duration.ofSeconds(10)) {
            PERF_LOGGER.warn("æ£€æµ‹åˆ°æ…¢æ“ä½œ: operation={}, duration={}ms, details={}", 
                event.getOperationType(),
                event.getDuration().toMillis(),
                event.getDetails());
            
            // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
            generatePerformanceReport(event);
        }
    }
    
    private void generatePerformanceReport(SlowOperationEvent event) {
        PerformanceReport report = PerformanceReport.builder()
            .timestamp(LocalDateTime.now())
            .operation(event.getOperationType())
            .duration(event.getDuration())
            .memoryUsage(getMemoryUsage())
            .threadInfo(getThreadInfo())
            .stackTrace(event.getStackTrace())
            .build();
            
        // ä¿å­˜æŠ¥å‘Šæˆ–å‘é€å‘Šè­¦
        savePerformanceReport(report);
    }
}
```

#### 8.2.2 çº¿ç¨‹æ± ç›‘æ§

```java
@Component
public class ThreadPoolMonitor {
    
    @Autowired
    private ThreadPoolTaskExecutor excelExecutor;
    
    @Scheduled(fixedRate = 30000) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void monitorThreadPool() {
        
        ThreadPoolExecutor executor = excelExecutor.getThreadPoolExecutor();
        
        int activeCount = executor.getActiveCount();
        int corePoolSize = executor.getCorePoolSize();
        int maximumPoolSize = executor.getMaximumPoolSize();
        long completedTaskCount = executor.getCompletedTaskCount();
        int queueSize = executor.getQueue().size();
        
        // æ£€æŸ¥çº¿ç¨‹æ± å¥åº·çŠ¶æ€
        if (activeCount >= maximumPoolSize * 0.8) {
            log.warn("çº¿ç¨‹æ± ä½¿ç”¨ç‡è¿‡é«˜: active={}, max={}, queue={}", 
                activeCount, maximumPoolSize, queueSize);
        }
        
        if (queueSize >= 100) {
            log.warn("çº¿ç¨‹æ± é˜Ÿåˆ—ç§¯å‹ä¸¥é‡: queueSize={}", queueSize);
        }
        
        // è®°å½•ç›‘æ§æŒ‡æ ‡
        Metrics.gauge("excel.threadpool.active", activeCount);
        Metrics.gauge("excel.threadpool.queue", queueSize);
    }
}
```

### 8.3 å¼‚å¸¸æ¢å¤ç­–ç•¥

#### 8.3.1 è‡ªåŠ¨é‡è¯•æœºåˆ¶

```java
@Component
public class RetryableExcelProcessor {
    
    @Retryable(
        value = {TransientException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000, multiplier = 2)
    )
    public ExcelReadResult<?> processWithRetry(String filePath, Class<?> clazz) {
        try {
            return excelService.read(filePath, clazz);
        } catch (Exception e) {
            log.warn("Excelå¤„ç†å¤±è´¥ï¼Œå‡†å¤‡é‡è¯•: filePath={}, error={}", filePath, e.getMessage());
            throw new TransientException("ä¸´æ—¶å¤„ç†å¤±è´¥", e);
        }
    }
    
    @Recover
    public ExcelReadResult<?> recover(TransientException ex, String filePath, Class<?> clazz) {
        log.error("Excelå¤„ç†é‡è¯•æ¬¡æ•°è€—å°½: filePath={}", filePath, ex);
        
        // é™çº§å¤„ç†ï¼šä½¿ç”¨åŸºç¡€æ¨¡å¼
        return processWithBasicMode(filePath, clazz);
    }
    
    private ExcelReadResult<?> processWithBasicMode(String filePath, Class<?> clazz) {
        try {
            // ä½¿ç”¨æœ€åŸºç¡€çš„é…ç½®é‡æ–°å¤„ç†
            ExcelReadConfig basicConfig = ExcelReadConfig.builder()
                .skipValidation(true)
                .ignoreErrors(true)
                .basicMode(true)
                .build();
                
            return excelService.readWithConfig(filePath, clazz, basicConfig);
        } catch (Exception e) {
            return ExcelReadResult.failure("åŸºç¡€æ¨¡å¼å¤„ç†ä¹Ÿå¤±è´¥: " + e.getMessage());
        }
    }
}
```

#### 8.3.2 ç†”æ–­å™¨æ¨¡å¼

```java
@Component
public class CircuitBreakerExcelService {
    
    private final CircuitBreaker circuitBreaker;
    
    public CircuitBreakerExcelService() {
        this.circuitBreaker = CircuitBreaker.ofDefaults("excelService");
        
        circuitBreaker.getEventPublisher()
            .onStateTransition(event -> 
                log.info("ç†”æ–­å™¨çŠ¶æ€å˜åŒ–: {} -> {}", 
                    event.getStateTransition().getFromState(),
                    event.getStateTransition().getToState()));
    }
    
    public ExcelReadResult<?> readWithCircuitBreaker(String filePath, Class<?> clazz) {
        
        Supplier<ExcelReadResult<?>> decoratedSupplier = CircuitBreaker
            .decorateSupplier(circuitBreaker, () -> excelService.read(filePath, clazz));
        
        Try<ExcelReadResult<?>> result = Try.ofSupplier(decoratedSupplier);
        
        return result.recover(throwable -> {
            if (throwable instanceof CallNotPermittedException) {
                log.warn("ç†”æ–­å™¨å¼€å¯ï¼Œæ‹’ç»è¯·æ±‚: {}", filePath);
                return ExcelReadResult.failure("æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•");
            } else {
                log.error("Excelå¤„ç†å¤±è´¥: {}", filePath, throwable);
                return ExcelReadResult.failure("å¤„ç†å¤±è´¥: " + throwable.getMessage());
            }
        });
    }
}
```

## 9. é«˜çº§æ‰©å±•æŒ‡å—

### 9.1 è‡ªå®šä¹‰è½¬æ¢å™¨å¼€å‘

#### 9.1.1 å¤æ‚å¯¹è±¡è½¬æ¢å™¨

```java
@Component
public class JsonObjectConverter implements ExcelDataConverter<JsonNode> {
    
    private final ObjectMapper objectMapper;
    
    public JsonObjectConverter(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }
    
    @Override
    public JsonNode convertToJavaData(String cellValue, ExcelContentProperty contentProperty, 
                                     GlobalConfiguration globalConfiguration) {
        if (StringUtils.isBlank(cellValue)) {
            return objectMapper.createObjectNode();
        }
        
        try {
            return objectMapper.readTree(cellValue);
        } catch (JsonProcessingException e) {
            throw new ExcelDataConvertException("JSONè§£æå¤±è´¥: " + cellValue, e);
        }
    }
    
    @Override
    public String convertToExcelData(JsonNode value, ExcelContentProperty contentProperty, 
                                   GlobalConfiguration globalConfiguration) {
        if (value == null || value.isNull()) {
            return "";
        }
        
        try {
            return objectMapper.writeValueAsString(value);
        } catch (JsonProcessingException e) {
            throw new ExcelDataConvertException("JSONåºåˆ—åŒ–å¤±è´¥", e);
        }
    }
    
    @Override
    public Class<JsonNode> supportJavaTypeKey() {
        return JsonNode.class;
    }
}
```

#### 9.1.2 åŠ å¯†å­—æ®µè½¬æ¢å™¨

```java
@Component
public class EncryptedFieldConverter implements ExcelDataConverter<String> {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Override
    public String convertToJavaData(String cellValue, ExcelContentProperty contentProperty, 
                                   GlobalConfiguration globalConfiguration) {
        if (StringUtils.isBlank(cellValue)) {
            return null;
        }
        
        // ä»Excelè¯»å–æ—¶è§£å¯†
        try {
            return encryptionService.decrypt(cellValue);
        } catch (Exception e) {
            throw new ExcelDataConvertException("è§£å¯†å¤±è´¥: " + cellValue, e);
        }
    }
    
    @Override
    public String convertToExcelData(String value, ExcelContentProperty contentProperty, 
                                   GlobalConfiguration globalConfiguration) {
        if (StringUtils.isBlank(value)) {
            return "";
        }
        
        // å†™å…¥Excelæ—¶åŠ å¯†
        try {
            return encryptionService.encrypt(value);
        } catch (Exception e) {
            throw new ExcelDataConvertException("åŠ å¯†å¤±è´¥", e);
        }
    }
    
    @Override
    public Class<String> supportJavaTypeKey() {
        return String.class;
    }
}

// ä½¿ç”¨åŠ å¯†è½¬æ¢å™¨
public class SensitiveDataEntity {
    
    @ExcelField(value = "èº«ä»½è¯å·", converter = EncryptedFieldConverter.class)
    private String idCard;
    
    @ExcelField(value = "æ‰‹æœºå·", converter = EncryptedFieldConverter.class)
    private String phoneNumber;
}
```

### 9.2 è‡ªå®šä¹‰æ•°æ®å¤„ç†å™¨

```java
@Component
public class AuditableDataProcessor<T> implements DataProcessor<T> {
    
    @Autowired
    private AuditService auditService;
    
    @Override
    public ProcessResult<T> preProcess(T data, ProcessContext context) {
        // è®°å½•å¤„ç†å¼€å§‹
        auditService.recordProcessStart(data, context);
        return ProcessResult.success(data);
    }
    
    @Override
    public ProcessResult<T> process(T data, ProcessContext context) {
        try {
            // æ‰§è¡Œä¸šåŠ¡éªŒè¯
            ValidationResult validation = validateBusinessRules(data, context);
            
            if (!validation.isValid()) {
                auditService.recordValidationFailure(data, validation.getErrors());
                return ProcessResult.failure(validation.getErrorMessage());
            }
            
            // æ•°æ®æ¸…æ´—å’Œæ ‡å‡†åŒ–
            T cleanedData = cleanAndNormalizeData(data);
            
            auditService.recordProcessSuccess(cleanedData);
            return ProcessResult.success(cleanedData);
            
        } catch (Exception e) {
            auditService.recordProcessError(data, e);
            return ProcessResult.error("å¤„ç†å¤±è´¥: " + e.getMessage());
        }
    }
    
    @Override
    public ProcessResult<T> postProcess(T data, ProcessContext context) {
        // è®°å½•æœ€ç»ˆç»“æœ
        auditService.recordProcessEnd(data, context);
        return ProcessResult.success(data);
    }
}
```

### 9.3 SPIæ‰©å±•æœºåˆ¶

#### 9.3.1 æ‰©å±•ç‚¹å®šä¹‰

```java
// æ‰©å±•ç‚¹æ¥å£
public interface ExcelServiceProvider {
    
    /**
     * æä¾›è€…ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
     */
    int getOrder();
    
    /**
     * æ˜¯å¦æ”¯æŒè¯¥ç±»å‹çš„è¯·æ±‚
     */
    boolean supports(Object request);
    
    /**
     * æä¾›æœåŠ¡å®ä¾‹
     */
    Object provide();
}

// SPIç®¡ç†å™¨
@Component
public class ExcelSpiManager {
    
    private final List<ExcelServiceProvider> providers;
    
    public ExcelSpiManager(List<ExcelServiceProvider> providers) {
        this.providers = providers.stream()
            .sorted(Comparator.comparingInt(ExcelServiceProvider::getOrder))
            .collect(Collectors.toList());
    }
    
    @SuppressWarnings("unchecked")
    public <T> Optional<T> getProvider(Class<T> type, Object request) {
        return providers.stream()
            .filter(provider -> provider.supports(request))
            .map(ExcelServiceProvider::provide)
            .filter(type::isInstance)
            .map(type::cast)
            .findFirst();
    }
}
```

## 10. é™„å½•å’Œå‚è€ƒ

### 10.1 é”™è¯¯ç å‚è€ƒ

| é”™è¯¯ç  | é”™è¯¯ç±»å‹ | æè¿°           | è§£å†³æ–¹æ¡ˆ               |
| ------ | -------- | -------------- | ---------------------- |
| 25001  | æ–‡ä»¶é”™è¯¯ | æ–‡ä»¶ä¸å­˜åœ¨     | æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®   |
| 25002  | æ–‡ä»¶é”™è¯¯ | æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ | ä½¿ç”¨.xlsxæˆ–.xlsæ ¼å¼    |
| 25003  | æ–‡ä»¶é”™è¯¯ | æ–‡ä»¶å¤§å°è¶…é™   | å‡å°æ–‡ä»¶å¤§å°æˆ–è°ƒæ•´é…ç½® |
| 25101  | è¯»å–é”™è¯¯ | Sheetä¸å­˜åœ¨    | æ£€æŸ¥Sheetåç§°æˆ–ç´¢å¼•    |
| 25102  | è¯»å–é”™è¯¯ | æ•°æ®æ ¼å¼é”™è¯¯   | æ£€æŸ¥æ•°æ®ç±»å‹å’Œæ ¼å¼     |
| 25201  | éªŒè¯é”™è¯¯ | å¿…å¡«å­—æ®µä¸ºç©º   | è¡¥å……å¿…å¡«æ•°æ®           |
| 25202  | éªŒè¯é”™è¯¯ | æ•°æ®é•¿åº¦è¶…é™   | ç¼©çŸ­æ•°æ®é•¿åº¦           |
| 25203  | éªŒè¯é”™è¯¯ | æ ¼å¼éªŒè¯å¤±è´¥   | ä¿®æ­£æ•°æ®æ ¼å¼           |

### 10.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

| åœºæ™¯         | æ•°æ®é‡  | å†…å­˜ä½¿ç”¨ | å¤„ç†æ—¶é—´ | æ¨èé…ç½®   |
| ------------ | ------- | -------- | -------- | ---------- |
| å°æ–‡ä»¶è¯»å–   | 1Kè¡Œ    | <50MB    | <1ç§’     | é»˜è®¤é…ç½®   |
| ä¸­ç­‰æ–‡ä»¶è¯»å– | 1ä¸‡è¡Œ   | <200MB   | <10ç§’    | æ‰¹å¤„ç†æ¨¡å¼ |
| å¤§æ–‡ä»¶è¯»å–   | 10ä¸‡è¡Œ  | <500MB   | <60ç§’    | æµå¼å¤„ç†   |
| è¶…å¤§æ–‡ä»¶è¯»å– | 100ä¸‡è¡Œ | <1GB     | <300ç§’   | åˆ†ç‰‡+å¼‚æ­¥  |

### 10.3 é…ç½®æ¨¡æ¿

#### 10.3.1 å¼€å‘ç¯å¢ƒé…ç½®

```yaml
# application-dev.yml
slavopolis:
  excel:
    enabled: true
    validation:
      max-file-size: 10485760  # 10MB
      max-rows: 5000
    error:
      fail-fast: true          # å¼€å‘ç¯å¢ƒå¿«é€Ÿå¤±è´¥
      collect-detail: true
    monitoring:
      enabled: true
      performance-stats: true
```

#### 10.3.2 ç”Ÿäº§ç¯å¢ƒé…ç½®

```yaml
# application-prod.yml
slavopolis:
  excel:
    enabled: true
    validation:
      max-file-size: 104857600  # 100MB
      max-rows: 100000
    async:
      thread-pool:
        core-size: 8
        max-size: 16
    performance:
      default-batch-size: 2000
      enable-cache: true
    error:
      fail-fast: false          # ç”Ÿäº§ç¯å¢ƒå®¹é”™
      max-errors: 1000
```

### 10.4 å¸¸ç”¨å·¥å…·å’Œå‘½ä»¤

#### 10.4.1 å†…å­˜åˆ†æ

```bash
# æŸ¥çœ‹Javaè¿›ç¨‹å†…å­˜ä½¿ç”¨
jmap -histo <pid>

# ç”Ÿæˆå†…å­˜å¿«ç…§
jmap -dump:live,format=b,file=heap.hprof <pid>

# æŸ¥çœ‹GCæƒ…å†µ
jstat -gc <pid> 1000
```

#### 10.4.2 æ€§èƒ½åˆ†æ

```bash
# CPUä½¿ç”¨ç‡åˆ†æ
top -H -p <pid>

# çº¿ç¨‹æ ˆåˆ†æ
jstack <pid> > thread_dump.txt

# æ€§èƒ½çƒ­ç‚¹åˆ†æ
java -jar async-profiler.jar -e cpu -d 30 -f profile.html <pid>
```

### 10.5 å­¦ä¹ èµ„æº

#### 10.5.1 å®˜æ–¹æ–‡æ¡£

- [EasyExcel å®˜æ–¹æ–‡æ¡£](https://easyexcel.opensource.alibaba.com/)
- [Spring Boot å®˜æ–¹æ–‡æ¡£](https://spring.io/projects/spring-boot)
- [Apache POI æ–‡æ¡£](https://poi.apache.org/)

#### 10.5.2 ç¤¾åŒºèµ„æº

- [GitHub Issue è¿½è¸ª](https://github.com/slavopolis/slavopolis-excel/issues)
- [æŠ€æœ¯åšå®¢å’Œæ¡ˆä¾‹åˆ†äº«](https://blog.slavopolis.club/excel)

## ğŸ‰ æ€»ç»“

æœ¬ä½¿ç”¨æŒ‡å—å…¨é¢ä»‹ç»äº† `slavopolis-excel` æ¨¡å—çš„å„ä¸ªæ–¹é¢ï¼Œä»åŸºç¡€ä½¿ç”¨åˆ°é«˜çº§æ‰©å±•ï¼Œä»æ€§èƒ½ä¼˜åŒ–åˆ°æ•…éšœæ’æŸ¥ã€‚é€šè¿‡æœ¬æŒ‡å—ï¼Œæ‚¨åº”è¯¥èƒ½å¤Ÿï¼š

âœ… **å¿«é€Ÿä¸Šæ‰‹**: åœ¨5åˆ†é’Ÿå†…é›†æˆå¹¶ä½¿ç”¨ExcelåŠŸèƒ½  
âœ… **æ·±åº¦åº”ç”¨**: æŒæ¡å„ç§å¤æ‚ä¸šåŠ¡åœºæ™¯çš„å®ç°æ–¹æ³•  
âœ… **æ€§èƒ½ä¼˜åŒ–**: å¤„ç†å¤§æ–‡ä»¶å’Œé«˜å¹¶å‘åœºæ™¯  
âœ… **é—®é¢˜è§£å†³**: ç‹¬ç«‹è¯Šæ–­å’Œè§£å†³å¸¸è§é—®é¢˜  
âœ… **æ‰©å±•å¼€å‘**: æ ¹æ®ä¸šåŠ¡éœ€æ±‚è¿›è¡Œå®šåˆ¶åŒ–å¼€å‘  

### ğŸ’¡ æœ€ä½³å®è·µæé†’

1. **è®¾è®¡å…ˆè¡Œ**: åœ¨ç¼–ç å‰æ˜ç¡®æ•°æ®æ¨¡å‹å’ŒéªŒè¯è§„åˆ™
2. **æ€§èƒ½è€ƒè™‘**: æ ¹æ®æ•°æ®é‡é€‰æ‹©åˆé€‚çš„å¤„ç†ç­–ç•¥
3. **é”™è¯¯å¤„ç†**: æä¾›å‹å¥½çš„é”™è¯¯ä¿¡æ¯å’Œæ¢å¤æœºåˆ¶
4. **ç›‘æ§è¿ç»´**: å»ºç«‹å®Œå–„çš„ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
5. **æŒç»­ä¼˜åŒ–**: æ ¹æ®å®é™…ä½¿ç”¨æƒ…å†µæŒç»­è°ƒä¼˜

### ğŸš€ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

- æ ¹æ®å¿«é€Ÿå¼€å§‹æŒ‡å—å®ŒæˆåŸºç¡€é›†æˆ
- é€‰æ‹©é€‚åˆä¸šåŠ¡åœºæ™¯çš„ç¤ºä¾‹è¿›è¡Œå®è·µ
- æ ¹æ®ç”Ÿäº§ç¯å¢ƒè¦æ±‚è¿›è¡Œæ€§èƒ½è°ƒä¼˜
- å»ºç«‹ç›‘æ§å’Œæ•…éšœå“åº”æœºåˆ¶
- æŒç»­å…³æ³¨æ–°ç‰ˆæœ¬å’Œæœ€ä½³å®è·µæ›´æ–°

å¦‚æœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿é€šè¿‡ GitHub Issue æˆ–æŠ€æœ¯äº¤æµç¾¤åé¦ˆã€‚ç¥æ‚¨ä½¿ç”¨æ„‰å¿«ï¼ ğŸŠ
