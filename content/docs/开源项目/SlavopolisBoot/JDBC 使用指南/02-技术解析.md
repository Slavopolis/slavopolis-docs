# æŠ€æœ¯è§£æ

## å‰è¨€

åœ¨ä¼ä¸šçº§Javaå¼€å‘ä¸­ï¼Œæ•°æ®è®¿é—®å±‚å¾€å¾€æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ä¹‹ä¸€ï¼Œå…¶è®¾è®¡è´¨é‡ç›´æ¥å½±å“åˆ°æ•´ä¸ªåº”ç”¨çš„æ€§èƒ½ã€å®‰å…¨æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚ä¼ ç»Ÿçš„æ•°æ®è®¿é—®æ–¹æ¡ˆè™½ç„¶èƒ½å¤Ÿæ»¡è¶³åŸºæœ¬éœ€æ±‚ï¼Œä½†åœ¨é¢å¯¹å¤æ‚çš„ä¼ä¸šçº§åœºæ™¯æ—¶ï¼Œå¾€å¾€æš´éœ²å‡ºè¯¸å¤šä¸è¶³ï¼šå®‰å…¨é˜²æŠ¤è–„å¼±ã€ç›‘æ§èƒ½åŠ›ç¼ºå¤±ã€æ˜ å°„æœºåˆ¶ç®€é™‹ã€äº‹åŠ¡ç®¡ç†å¤æ‚ç­‰ã€‚

**Slavopolis-JDBC** ä½œä¸ºä¸€ä¸ªä¼ä¸šçº§æ•°æ®è®¿é—®è§£å†³æ–¹æ¡ˆï¼Œåœ¨è®¾è®¡ä¹‹åˆå°±å……åˆ†è€ƒè™‘äº†è¿™äº›ç—›ç‚¹ï¼Œé€šè¿‡åˆ›æ–°çš„æ¶æ„è®¾è®¡å’Œç²¾å¿ƒçš„æŠ€æœ¯é€‰å‹ï¼Œæ„å»ºäº†ä¸€ä¸ªé›†å®‰å…¨ã€æ€§èƒ½ã€æ˜“ç”¨æ€§äºä¸€ä½“çš„æ•°æ®è®¿é—®æ¡†æ¶ã€‚

### ğŸ¯ æŠ€æœ¯æ„¿æ™¯

- **ğŸ—ï¸ æ¶æ„å…ˆè¿›æ€§**ï¼šé‡‡ç”¨ç°ä»£åŒ–çš„åˆ†å±‚æ¶æ„å’Œæ¨¡å—åŒ–è®¾è®¡ï¼Œç¡®ä¿ç³»ç»Ÿçš„å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§
- **ğŸ›¡ï¸ å®‰å…¨è‡³ä¸Š**ï¼šæ„å»ºå¤šå±‚æ¬¡çš„å®‰å…¨é˜²æŠ¤ä½“ç³»ï¼Œä»æºå¤´æœç»SQLæ³¨å…¥ç­‰å®‰å…¨é£é™©
- **ğŸ“Š å¯è§‚æµ‹æ€§**ï¼šå†…ç½®å®Œå–„çš„ç›‘æ§å’Œç»Ÿè®¡æœºåˆ¶ï¼Œä¸ºæ€§èƒ½ä¼˜åŒ–æä¾›æ•°æ®æ”¯æ’‘
- **ğŸš€ é«˜æ€§èƒ½**ï¼šé€šè¿‡æ™ºèƒ½ç¼“å­˜ã€æ‰¹å¤„ç†ä¼˜åŒ–ã€è¿æ¥æ± ç®¡ç†ç­‰æŠ€æœ¯æ‰‹æ®µï¼Œç¡®ä¿ç³»ç»Ÿé«˜æ€§èƒ½è¿è¡Œ
- **ğŸ¨ å¼€å‘å‹å¥½**ï¼šæä¾›ç®€æ´æ˜“ç”¨çš„APIè®¾è®¡ï¼Œé™ä½å¼€å‘å¤æ‚åº¦ï¼Œæå‡å¼€å‘æ•ˆç‡

### ğŸ“ è®¾è®¡åŸåˆ™

1. **å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªç»„ä»¶éƒ½æœ‰æ˜ç¡®çš„èŒè´£è¾¹ç•Œï¼Œé¿å…åŠŸèƒ½è€¦åˆ
2. **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­ï¼Œæ”¯æŒçµæ´»çš„åŠŸèƒ½æ‰©å±•
3. **ä¾èµ–å€’ç½®åŸåˆ™**ï¼šä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°ï¼Œæé«˜ç³»ç»Ÿçš„çµæ´»æ€§
4. **æ¥å£éš”ç¦»åŸåˆ™**ï¼šæä¾›ç»†ç²’åº¦çš„æ¥å£è®¾è®¡ï¼Œé¿å…æ¥å£æ±¡æŸ“
5. **æœ€å°æƒŠè®¶åŸåˆ™**ï¼šAPIè®¾è®¡ç¬¦åˆå¼€å‘è€…çš„ç›´è§‰ï¼Œé™ä½å­¦ä¹ æˆæœ¬

## æ•´ä½“æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

```mermaid
<function_calls>
<invoke name="create_diagram">
<parameter name="content">graph TB
    subgraph "åº”ç”¨å±‚"
        A[Service Layer] --> B[JdbcOperations Interface]
    end
    

    subgraph "Slavopolis-JDBC æ ¸å¿ƒå±‚"
        B --> C[EnhancedJdbcTemplate]
        C --> D[Security Module]
        C --> E[Monitoring Module]
        C --> F[Transaction Module]
        C --> G[Mapping Module]
        C --> H[Parameter Module]
    end
    
    subgraph "Spring JDBC åŸºç¡€å±‚"
        C --> I[NamedParameterJdbcTemplate]
        I --> J[JdbcTemplate]
    end
    
    subgraph "æ•°æ®æºå±‚"
        J --> K[DataSource]
        K --> L[Connection Pool]
        L --> M[Database]
    end
    
    subgraph "é…ç½®ç®¡ç†"
        N[JdbcProperties] --> C
        O[SqlSecurityConfig] --> D
        P[Spring Boot AutoConfiguration] --> C
    end
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
    style D fill:#ffebee
    style E fill:#e8f5e8
    style F fill:#fff3e0
    style G fill:#f1f8e9
    style H fill:#fce4ec
```

### æ¶æ„åˆ†å±‚è¯´æ˜

#### 1. åº”ç”¨å±‚ï¼ˆApplication Layerï¼‰
- **èŒè´£**ï¼šä¸šåŠ¡é€»è¾‘å¤„ç†ï¼Œæ•°æ®è®¿é—®éœ€æ±‚å‘èµ·
- **ç‰¹ç‚¹**ï¼šé€šè¿‡ç»Ÿä¸€çš„`JdbcOperations`æ¥å£ä¸æ•°æ®è®¿é—®å±‚äº¤äº’
- **ä¼˜åŠ¿**ï¼šè§£è€¦ä¸šåŠ¡é€»è¾‘ä¸æ•°æ®è®¿é—®å®ç°ï¼Œä¾¿äºå•å…ƒæµ‹è¯•å’Œç»´æŠ¤

#### 2. Slavopolis-JDBC æ ¸å¿ƒå±‚ï¼ˆCore Layerï¼‰
- **èŒè´£**ï¼šæä¾›å¢å¼ºçš„æ•°æ®è®¿é—®èƒ½åŠ›ï¼ŒåŒ…æ‹¬å®‰å…¨é˜²æŠ¤ã€ç›‘æ§ç»Ÿè®¡ã€äº‹åŠ¡ç®¡ç†ç­‰
- **ç‰¹ç‚¹**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œå„ç»„ä»¶èŒè´£æ¸…æ™°ï¼Œå¯ç‹¬ç«‹æ‰©å±•
- **ä¼˜åŠ¿**ï¼šåœ¨ä¿æŒSpring JDBCç®€æ´æ€§çš„åŸºç¡€ä¸Šï¼Œæä¾›ä¼ä¸šçº§å¢å¼ºåŠŸèƒ½

#### 3. Spring JDBC åŸºç¡€å±‚ï¼ˆFoundation Layerï¼‰
- **èŒè´£**ï¼šæä¾›åŸºç¡€çš„JDBCæ“ä½œèƒ½åŠ›å’Œå‚æ•°ç»‘å®šæœºåˆ¶
- **ç‰¹ç‚¹**ï¼šæˆç†Ÿç¨³å®šï¼Œæ€§èƒ½ä¼˜å¼‚ï¼Œç¤¾åŒºæ”¯æŒå®Œå–„
- **ä¼˜åŠ¿**ï¼šå……åˆ†åˆ©ç”¨Springç”Ÿæ€çš„æˆç†Ÿç»„ä»¶ï¼Œé™ä½å¼€å‘é£é™©

#### 4. æ•°æ®æºå±‚ï¼ˆDataSource Layerï¼‰
- **èŒè´£**ï¼šç®¡ç†æ•°æ®åº“è¿æ¥ï¼Œæä¾›è¿æ¥æ± æœåŠ¡
- **ç‰¹ç‚¹**ï¼šæ”¯æŒå¤šç§æ•°æ®æºå®ç°ï¼Œå¦‚HikariCPã€Druidç­‰
- **ä¼˜åŠ¿**ï¼šè¿æ¥æ± ä¼˜åŒ–ï¼Œæå‡æ•°æ®åº“è®¿é—®æ€§èƒ½

## æ ¸å¿ƒç»„ä»¶æ·±åº¦è§£æ

### 1. EnhancedJdbcTemplate - æ ¸å¿ƒå¼•æ“

`EnhancedJdbcTemplate`æ˜¯æ•´ä¸ªæ¡†æ¶çš„æ ¸å¿ƒç»„ä»¶ï¼Œå®ƒåœ¨Springçš„`NamedParameterJdbcTemplate`åŸºç¡€ä¸Šè¿›è¡Œäº†å…¨é¢å¢å¼ºã€‚

#### è®¾è®¡ç†å¿µ

```java
@Slf4j
public class EnhancedJdbcTemplate implements JdbcOperations {
    
    // æ ¸å¿ƒä¾èµ–ç»„ä»¶
    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;
    private final DataSourceTransactionManager transactionManager;
    private final SqlExecutionMonitor executionMonitor;
    private final SqlInjectionValidator sqlValidator;
    private final SqlSecurityConfig securityConfig;
    
    // æ™ºèƒ½ç¼“å­˜æœºåˆ¶
    private final Map<Class<?>, RowMapper<?>> rowMapperCache = new ConcurrentHashMap<>();
    
    // çº¿ç¨‹å®‰å…¨çš„äº‹åŠ¡çŠ¶æ€ç®¡ç†
    private final ThreadLocal<TransactionStatus> currentTransactionStatus = new ThreadLocal<>();
}
```

#### æ ¸å¿ƒæ‰§è¡Œæµç¨‹

<function_calls>
<invoke name="create_diagram">
<parameter name="content">sequenceDiagram
    participant App as Application
    participant EJT as EnhancedJdbcTemplate
    participant SEC as SecurityModule
    participant MON as MonitoringModule
    participant NPJT as NamedParameterJdbcTemplate
    participant DB as Database
    
    App->>EJT: executeQuery(sql, params)
    EJT->>SEC: validateSql(sql, params)
    SEC-->>EJT: validation result
    EJT->>MON: recordStart()
    EJT->>NPJT: query(sql, params)
    NPJT->>DB: execute SQL
    DB-->>NPJT: result set
    NPJT-->>EJT: mapped objects
    EJT->>MON: recordEnd(success/failure)
         EJT-->>App: query result

#### å…³é”®æŠ€æœ¯ç‰¹æ€§

**1. å¤šå±‚å®‰å…¨éªŒè¯æœºåˆ¶**

```java
private <T> T executeQuery(String sql, Map<String, Object> params, boolean enableLogging, QueryExecutor<T> executor) {
    // ç¬¬ä¸€å±‚ï¼šç»¼åˆSQLå®‰å…¨éªŒè¯
    String validatedSql = performComprehensiveSqlValidation(sql, params);
    
    // ç¬¬äºŒå±‚ï¼šå‚æ•°å®‰å…¨æ£€æŸ¥
    validateParameters(params);
    
    // ç¬¬ä¸‰å±‚ï¼šæ•æ„Ÿä¿¡æ¯æ©ç å¤„ç†
    String maskedSql = maskSensitiveSql(sql);
    
    // æ‰§è¡Œç›‘æ§å’Œæ—¥å¿—è®°å½•
    long startTime = System.currentTimeMillis();
    try {
        T result = executor.execute();
        executionMonitor.recordQueryExecution(validatedSql, params, System.currentTimeMillis() - startTime, true);
        return result;
    } catch (Exception e) {
        executionMonitor.recordQueryExecution(validatedSql, params, System.currentTimeMillis() - startTime, false);
        throw e;
    }
}
```

**2. æ™ºèƒ½ç»“æœé›†æ˜ å°„**

```java
@SuppressWarnings("unchecked")
private <T> RowMapper<T> getOrCreateRowMapper(Class<T> requiredType) {
    if (isSimpleType(requiredType)) {
        return null; // ä½¿ç”¨Springé»˜è®¤æ˜ å°„
    }
    
    // ä»ç¼“å­˜ä¸­è·å–æˆ–åˆ›å»ºæ–°çš„æ˜ å°„å™¨
    RowMapper<T> rowMapper = (RowMapper<T>) rowMapperCache.get(requiredType);
    if (rowMapper == null) {
        IntelligentRowMapper<T> intelligentMapper = IntelligentRowMapper.of(requiredType);
        rowMapperCache.put(requiredType, intelligentMapper);
        rowMapper = intelligentMapper;
    }
    
    return rowMapper;
}
```

**3. ä¼ä¸šçº§åˆ†é¡µæŸ¥è¯¢ä¼˜åŒ–**

```java
public PageResult.PageData<T> queryForPage(String sql, Map<String, Object> params, Class<T> requiredType, int pageNum, int pageSize) {
    validatePageParams(pageNum, pageSize);
    
    // æ™ºèƒ½æ„å»ºè®¡æ•°SQL
    String countSql = buildCountSql(sql);
    long total = queryForCount(countSql, params);
    
    if (total == 0) {
        return PageResult.PageData.empty(pageNum, pageSize);
    }
    
    // æ„å»ºåˆ†é¡µSQL
    String pageSql = buildPageSql(sql, pageNum, pageSize);
    List<T> records = queryForList(pageSql, params, requiredType);
    
    return PageResult.PageData.of(pageNum, pageSize, total, records);
}
```

### 2. Security Module - å®‰å…¨é˜²æŠ¤ä½“ç³»

å®‰å…¨æ¨¡å—æ˜¯Slavopolis-JDBCçš„æ ¸å¿ƒç«äº‰åŠ›ä¹‹ä¸€ï¼Œæä¾›äº†å¤šå±‚æ¬¡ã€å…¨æ–¹ä½çš„å®‰å…¨é˜²æŠ¤æœºåˆ¶ã€‚

#### å®‰å…¨æ¶æ„è®¾è®¡

<function_calls>
<invoke name="create_diagram">
<parameter name="content">graph TD
    A[SQL Input] --> B[SQL Injection Validator]
    B --> C[Parameter Validator]
    C --> D[Sensitive Data Masker]
    D --> E[DDL Operation Checker]
    E --> F[Unsafe Operation Detector]
    F --> G[Security Logger]
    G --> H[Safe SQL Execution]
    
    subgraph "Security Configuration"
        I[SqlSecurityConfig]
        J[Dangerous Keywords]
        K[Sensitive Patterns]
        L[Security Limits]
    end
    
    I --> B
    J --> B
    K --> D
    L --> C
    
    style A fill:#ffcdd2
    style H fill:#c8e6c9
    style B fill:#fff3e0
    style C fill:#fff3e0
    style D fill:#fff3e0
    style E fill:#fff3e0
    style F fill:#fff3e0
    style G fill:#fff3e0

#### æ ¸å¿ƒå®‰å…¨æŠ€æœ¯

**1. SQLæ³¨å…¥æ£€æµ‹ç®—æ³•**

```java
public class SqlInjectionValidator {
    
    // å¤šå±‚æ£€æµ‹æœºåˆ¶
    public void validateSql(String sql) {
        // ç¬¬ä¸€å±‚ï¼šå…³é”®è¯æ£€æµ‹
        detectDangerousKeywords(sql);
        
        // ç¬¬äºŒå±‚ï¼šè¯­æ³•ç»“æ„åˆ†æ
        analyzeSqlStructure(sql);
        
        // ç¬¬ä¸‰å±‚ï¼šæ³¨å…¥æ¨¡å¼è¯†åˆ«
        detectInjectionPatterns(sql);
        
        // ç¬¬å››å±‚ï¼šç¼–ç æ”»å‡»æ£€æµ‹
        detectEncodingAttacks(sql);
    }
    
    private void detectDangerousKeywords(String sql) {
        String upperSql = sql.toUpperCase();
        for (String keyword : DANGEROUS_KEYWORDS) {
            if (upperSql.contains(keyword)) {
                // è¿›ä¸€æ­¥éªŒè¯æ˜¯å¦ä¸ºæ¶æ„ä½¿ç”¨
                if (ismaliciousUsage(sql, keyword)) {
                    throw new SecurityException("æ£€æµ‹åˆ°æ½œåœ¨çš„SQLæ³¨å…¥æ”»å‡»: " + keyword);
                }
            }
        }
    }
    
    private void detectInjectionPatterns(String sql) {
        // æ£€æµ‹å¸¸è§æ³¨å…¥æ¨¡å¼
        Pattern[] injectionPatterns = {
            Pattern.compile("'.*(OR|AND).*'.*=.*'", Pattern.CASE_INSENSITIVE),
            Pattern.compile("\\b(UNION|UNION\\s+ALL)\\b.*\\bSELECT\\b", Pattern.CASE_INSENSITIVE),
            Pattern.compile("';\\s*(DROP|DELETE|UPDATE|INSERT)", Pattern.CASE_INSENSITIVE),
            Pattern.compile("\\b(EXEC|EXECUTE)\\b.*\\(", Pattern.CASE_INSENSITIVE)
        };
        
        for (Pattern pattern : injectionPatterns) {
            if (pattern.matcher(sql).find()) {
                throw new SecurityException("æ£€æµ‹åˆ°SQLæ³¨å…¥æ”»å‡»æ¨¡å¼");
            }
        }
    }
}
```

**2. æ•æ„Ÿä¿¡æ¯æ©ç æœºåˆ¶**

```java
public class SensitiveSqlMasker {
    
    public String maskSensitiveSql(String sql) {
        if (!securityConfig.isSensitiveDataMasking()) {
            return sql;
        }
        
        String maskedSql = sql;
        
        // æ©ç WHEREæ¡ä»¶ä¸­çš„æ•æ„Ÿå€¼
        maskedSql = maskWhereConditions(maskedSql);
        
        // æ©ç INSERT VALUESä¸­çš„æ•æ„Ÿå€¼
        maskedSql = maskInsertValues(maskedSql);
        
        // æ©ç UPDATE SETä¸­çš„æ•æ„Ÿå€¼
        maskedSql = maskUpdateValues(maskedSql);
        
        // æ©ç å‡½æ•°å‚æ•°ä¸­çš„æ•æ„Ÿå€¼
        maskedSql = maskFunctionParameters(maskedSql);
        
        return maskedSql;
    }
    
    private String maskWhereConditions(String sql) {
        // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…WHEREæ¡ä»¶ä¸­çš„æ•æ„Ÿå­—æ®µ
        Pattern pattern = Pattern.compile(
            "\\b(" + String.join("|", SENSITIVE_FIELDS) + ")\\s*=\\s*'([^']*)'",
            Pattern.CASE_INSENSITIVE
        );
        
        return pattern.matcher(sql).replaceAll(match -> {
            String field = match.group(1);
            return field + " = '***'";
        });
    }
}
```

**3. å‚æ•°å®‰å…¨éªŒè¯**

```java
public void validateParameter(String paramName, Object paramValue) {
    if (paramValue == null) return;
    
    String stringValue = paramValue.toString();
    
    // æ£€æŸ¥å‚æ•°é•¿åº¦
    if (stringValue.length() > securityConfig.getMaxParameterLength()) {
        throw new SecurityException("å‚æ•°å€¼è¿‡é•¿: " + paramName);
    }
    
    // æ£€æŸ¥æ•æ„Ÿå‚æ•°
    if (isSensitiveParameter(paramName)) {
        validateSensitiveParameter(paramName, stringValue);
    }
    
    // æ£€æŸ¥å‚æ•°å€¼ä¸­çš„å±é™©å†…å®¹
    validateParameterContent(stringValue);
}

private void validateParameterContent(String value) {
    // æ£€æµ‹SQLæ³¨å…¥å°è¯•
    if (containsSqlInjectionAttempt(value)) {
        throw new SecurityException("å‚æ•°å€¼åŒ…å«æ½œåœ¨çš„SQLæ³¨å…¥å†…å®¹");
    }
    
    // æ£€æµ‹è„šæœ¬æ³¨å…¥
    if (containsScriptInjection(value)) {
        throw new SecurityException("å‚æ•°å€¼åŒ…å«æ½œåœ¨çš„è„šæœ¬æ³¨å…¥å†…å®¹");
    }
}
```

### 3. Monitoring Module - æ€§èƒ½ç›‘æ§ä½“ç³»

ç›‘æ§æ¨¡å—æä¾›äº†å…¨é¢çš„SQLæ‰§è¡Œç›‘æ§å’Œæ€§èƒ½ç»Ÿè®¡åŠŸèƒ½ï¼Œä¸ºç³»ç»Ÿä¼˜åŒ–æä¾›æ•°æ®æ”¯æ’‘ã€‚

#### ç›‘æ§æ¶æ„è®¾è®¡

<function_calls>
<invoke name="create_diagram">
<parameter name="content">graph LR
    subgraph "æ•°æ®æ”¶é›†å±‚"
        A[SQL Execution Monitor] --> B[Query Statistics]
        A --> C[Update Statistics]
        A --> D[Batch Statistics]
        A --> E[Slow Query Detector]
    end
    
    subgraph "æ•°æ®å­˜å‚¨å±‚"
        B --> F[Concurrent Statistics Store]
        C --> F
        D --> F
        E --> G[Slow Query Cache]
    end
    
    subgraph "æ•°æ®åˆ†æå±‚"
        F --> H[Performance Analyzer]
        G --> H
        H --> I[Trend Analysis]
        H --> J[Anomaly Detection]
    end
    
    subgraph "æ•°æ®è¾“å‡ºå±‚"
        I --> K[Metrics Export]
        J --> L[Alert System]
        K --> M[Monitoring Dashboard]
        L --> N[Notification Service]
    end
    
    style A fill:#e3f2fd
    style H fill:#f3e5f5
    style K fill:#e8f5e8
    style L fill:#ffebee

#### æ ¸å¿ƒç›‘æ§æŠ€æœ¯

**1. é«˜æ€§èƒ½ç»Ÿè®¡æ•°æ®æ”¶é›†**

```java
@Slf4j
public class SqlExecutionMonitor {
    
    // ä½¿ç”¨åŸå­ç±»ç¡®ä¿çº¿ç¨‹å®‰å…¨å’Œé«˜æ€§èƒ½
    private final AtomicLong queryCount = new AtomicLong(0);
    private final AtomicLong querySuccessCount = new AtomicLong(0);
    private final AtomicLong queryFailureCount = new AtomicLong(0);
    private final AtomicLong totalQueryTime = new AtomicLong(0);
    
    // ä½¿ç”¨ConcurrentHashMapå­˜å‚¨æ…¢æŸ¥è¯¢ä¿¡æ¯
    private final Map<String, SlowQueryInfo> slowQueries = new ConcurrentHashMap<>();
    
    public void recordQueryExecution(String sql, Map<String, Object> params, long executionTime, boolean success) {
        if (!monitoringEnabled) return;
        
        // åŸå­æ“ä½œæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        queryCount.incrementAndGet();
        totalQueryTime.addAndGet(executionTime);
        
        if (success) {
            querySuccessCount.incrementAndGet();
        } else {
            queryFailureCount.incrementAndGet();
        }
        
        // æ…¢æŸ¥è¯¢æ£€æµ‹å’Œè®°å½•
        if (executionTime > slowQueryThreshold) {
            recordSlowQuery(sql, params, executionTime);
        }
    }
    
    private void recordSlowQuery(String sql, Map<String, Object> params, long executionTime) {
        String sqlKey = sql.trim();
        
        // ä½¿ç”¨computeæ–¹æ³•ç¡®ä¿åŸå­æ€§æ›´æ–°
        slowQueries.compute(sqlKey, (key, existing) -> {
            if (existing == null) {
                return new SlowQueryInfo(sql, executionTime, 1, System.currentTimeMillis());
            } else {
                existing.incrementCount();
                if (executionTime > existing.getMaxTime()) {
                    existing.setMaxTime(executionTime);
                    existing.setLastOccurrence(System.currentTimeMillis());
                }
                return existing;
            }
        });
        
        // è®°å½•æ…¢æŸ¥è¯¢æ—¥å¿—
        log.warn("æ…¢æŸ¥è¯¢æ£€æµ‹ - SQL: {}, æ‰§è¡Œæ—¶é—´: {}ms, å‚æ•°: {}", 
            maskSensitiveSql(sql), executionTime, maskSensitiveParams(params));
    }
}
```

**2. æ™ºèƒ½æ…¢æŸ¥è¯¢åˆ†æ**

```java
public class SlowQueryAnalyzer {
    
    public SlowQueryReport analyzeSlowQueries(Map<String, SlowQueryInfo> slowQueries) {
        SlowQueryReport report = new SlowQueryReport();
        
        // æŒ‰æ‰§è¡Œæ—¶é—´æ’åº
        List<SlowQueryInfo> sortedQueries = slowQueries.values().stream()
            .sorted((a, b) -> Long.compare(b.getMaxTime(), a.getMaxTime()))
            .collect(Collectors.toList());
        
        // åˆ†ææŸ¥è¯¢æ¨¡å¼
        Map<String, Integer> queryPatterns = analyzeQueryPatterns(sortedQueries);
        
        // è¯†åˆ«æ€§èƒ½çƒ­ç‚¹
        List<String> performanceHotspots = identifyPerformanceHotspots(sortedQueries);
        
        // ç”Ÿæˆä¼˜åŒ–å»ºè®®
        List<OptimizationSuggestion> suggestions = generateOptimizationSuggestions(sortedQueries);
        
        report.setSlowQueries(sortedQueries);
        report.setQueryPatterns(queryPatterns);
        report.setPerformanceHotspots(performanceHotspots);
        report.setOptimizationSuggestions(suggestions);
        
        return report;
    }
    
    private List<OptimizationSuggestion> generateOptimizationSuggestions(List<SlowQueryInfo> slowQueries) {
        List<OptimizationSuggestion> suggestions = new ArrayList<>();
        
        for (SlowQueryInfo query : slowQueries) {
            String sql = query.getSql().toLowerCase();
            
            // æ£€æŸ¥æ˜¯å¦ç¼ºå°‘ç´¢å¼•
            if (sql.contains("where") && !sql.contains("index")) {
                suggestions.add(new OptimizationSuggestion(
                    "INDEX_MISSING", 
                    "è€ƒè™‘ä¸ºWHEREæ¡ä»¶å­—æ®µæ·»åŠ ç´¢å¼•",
                    query.getSql()
                ));
            }
            
            // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†SELECT *
            if (sql.contains("select *")) {
                suggestions.add(new OptimizationSuggestion(
                    "SELECT_ALL_COLUMNS",
                    "é¿å…ä½¿ç”¨SELECT *ï¼Œæ˜ç¡®æŒ‡å®šéœ€è¦çš„å­—æ®µ",
                    query.getSql()
                ));
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¤æ‚çš„JOINæ“ä½œ
            if (countOccurrences(sql, "join") > 3) {
                suggestions.add(new OptimizationSuggestion(
                    "COMPLEX_JOIN",
                    "è€ƒè™‘ä¼˜åŒ–å¤æ‚çš„JOINæ“ä½œæˆ–ä½¿ç”¨åˆ†æ­¥æŸ¥è¯¢",
                    query.getSql()
                ));
            }
        }
        
        return suggestions;
    }
}
```

**3. å®æ—¶æ€§èƒ½æŒ‡æ ‡è®¡ç®—**

```java
public class PerformanceMetricsCalculator {
    
    public PerformanceMetrics calculateMetrics(SqlExecutionMonitor monitor) {
        QueryStatistics queryStats = monitor.getQueryStatistics();
        UpdateStatistics updateStats = monitor.getUpdateStatistics();
        BatchUpdateStatistics batchStats = monitor.getBatchUpdateStatistics();
        
        return PerformanceMetrics.builder()
            .totalOperations(queryStats.getTotalQueries() + updateStats.getTotalUpdates() + batchStats.getTotalBatchUpdates())
            .successRate(calculateSuccessRate(queryStats, updateStats, batchStats))
            .averageResponseTime(calculateAverageResponseTime(queryStats, updateStats, batchStats))
            .throughput(calculateThroughput(queryStats, updateStats, batchStats))
            .slowQueryCount(monitor.getSlowQueries().size())
            .errorRate(calculateErrorRate(queryStats, updateStats, batchStats))
            .build();
    }
    
    private double calculateSuccessRate(QueryStatistics queryStats, UpdateStatistics updateStats, BatchUpdateStatistics batchStats) {
        long totalSuccess = queryStats.getSuccessQueries() + updateStats.getSuccessUpdates() + batchStats.getSuccessBatchUpdates();
        long totalOperations = queryStats.getTotalQueries() + updateStats.getTotalUpdates() + batchStats.getTotalBatchUpdates();
        
        return totalOperations > 0 ? (double) totalSuccess / totalOperations * 100 : 0.0;
    }
    
    private double calculateThroughput(QueryStatistics queryStats, UpdateStatistics updateStats, BatchUpdateStatistics batchStats) {
        long totalOperations = queryStats.getTotalQueries() + updateStats.getTotalUpdates() + batchStats.getTotalBatchUpdates();
        long totalTime = queryStats.getTotalQueryTime() + updateStats.getTotalUpdateTime() + batchStats.getTotalBatchUpdateTime();
        
        return totalTime > 0 ? (double) totalOperations / (totalTime / 1000.0) : 0.0; // æ“ä½œæ•°/ç§’
    }
}
```

### 4. Mapping Module - æ™ºèƒ½æ˜ å°„ç³»ç»Ÿ

æ˜ å°„æ¨¡å—æä¾›äº†é«˜æ€§èƒ½ã€æ™ºèƒ½åŒ–çš„ç»“æœé›†æ˜ å°„åŠŸèƒ½ï¼Œæ”¯æŒè‡ªåŠ¨é©¼å³°è½¬æ¢ã€ç±»å‹å®‰å…¨æ˜ å°„ç­‰ç‰¹æ€§ã€‚

#### æ˜ å°„æ¶æ„è®¾è®¡

<function_calls>
<invoke name="create_diagram">
<parameter name="content">graph TD
    A[ResultSet] --> B[IntelligentRowMapper]
    B --> C[Field Analysis]
    C --> D[Type Conversion]
    D --> E[Naming Strategy]
    E --> F[Cache Management]
    F --> G[Target Object]
    
    subgraph "æ˜ å°„ç­–ç•¥"
        H[INTELLIGENT Strategy]
        I[STRICT Strategy]
        J[LENIENT Strategy]
    end
    
    subgraph "ç±»å‹è½¬æ¢å™¨"
        K[Primitive Converter]
        L[Date Converter]
        M[Enum Converter]
        N[Custom Converter]
    end
    
    subgraph "å‘½åè½¬æ¢"
        O[CamelCase Converter]
        P[SnakeCase Converter]
        Q[Custom Naming]
    end
    
    B --> H
    B --> I
    B --> J
    
    D --> K
    D --> L
    D --> M
    D --> N
    
    E --> O
    E --> P
    E --> Q
    
    style A fill:#e3f2fd
    style G fill:#c8e6c9
    style B fill:#f3e5f5

#### æ ¸å¿ƒæ˜ å°„æŠ€æœ¯

**1. æ™ºèƒ½è¡Œæ˜ å°„å™¨å®ç°**

```java
public class IntelligentRowMapper<T> implements RowMapper<T> {
    
    private final Class<T> mappedClass;
    private final Map<String, PropertyDescriptor> propertyMap;
    private final MappingStrategy strategy;
    
    public static <T> IntelligentRowMapper<T> of(Class<T> mappedClass) {
        return new IntelligentRowMapper<>(mappedClass, MappingStrategy.INTELLIGENT);
    }
    
    @Override
    public T mapRow(ResultSet rs, int rowNum) throws SQLException {
        T mappedObject = BeanUtils.instantiateClass(this.mappedClass);
        ResultSetMetaData metaData = rs.getMetaData();
        int columnCount = metaData.getColumnCount();
        
        for (int index = 1; index <= columnCount; index++) {
            String columnName = getColumnName(metaData, index);
            String propertyName = convertColumnNameToPropertyName(columnName);
            
            PropertyDescriptor property = propertyMap.get(propertyName);
            if (property != null && property.getWriteMethod() != null) {
                Object value = getColumnValue(rs, index, property.getPropertyType());
                if (value != null) {
                    try {
                        property.getWriteMethod().invoke(mappedObject, value);
                    } catch (Exception ex) {
                        handleMappingException(columnName, propertyName, value, ex);
                    }
                }
            }
        }
        
        return mappedObject;
    }
    
    private Object getColumnValue(ResultSet rs, int index, Class<?> targetType) throws SQLException {
        Object value = rs.getObject(index);
        if (value == null) {
            return null;
        }
        
        // æ™ºèƒ½ç±»å‹è½¬æ¢
        return convertValue(value, targetType);
    }
    
    private Object convertValue(Object value, Class<?> targetType) {
        if (targetType.isAssignableFrom(value.getClass())) {
            return value;
        }
        
        // æ—¶é—´ç±»å‹è½¬æ¢
        if (targetType == LocalDateTime.class && value instanceof Timestamp) {
            return ((Timestamp) value).toLocalDateTime();
        }
        
        if (targetType == LocalDate.class && value instanceof Date) {
            return ((Date) value).toLocalDate();
        }
        
        // æšä¸¾ç±»å‹è½¬æ¢
        if (targetType.isEnum() && value instanceof String) {
            return Enum.valueOf((Class<Enum>) targetType, (String) value);
        }
        
        // æ•°å€¼ç±»å‹è½¬æ¢
        if (Number.class.isAssignableFrom(targetType) && value instanceof Number) {
            return convertNumber((Number) value, targetType);
        }
        
        // å­—ç¬¦ä¸²è½¬æ¢
        if (targetType == String.class) {
            return value.toString();
        }
        
        return value;
    }
}
```

**2. é«˜æ€§èƒ½å‘½åè½¬æ¢ç­–ç•¥**

```java
public class NamingConversionStrategy {
    
    // ä½¿ç”¨ç¼“å­˜æå‡æ€§èƒ½
    private static final Map<String, String> CAMEL_CASE_CACHE = new ConcurrentHashMap<>();
    private static final Map<String, String> SNAKE_CASE_CACHE = new ConcurrentHashMap<>();
    
    public static String underscoreToCamelCase(String underscoreName) {
        return CAMEL_CASE_CACHE.computeIfAbsent(underscoreName, name -> {
            if (!name.contains("_")) {
                return name;
            }
            
            StringBuilder result = new StringBuilder();
            boolean capitalizeNext = false;
            
            for (char c : name.toCharArray()) {
                if (c == '_') {
                    capitalizeNext = true;
                } else {
                    if (capitalizeNext) {
                        result.append(Character.toUpperCase(c));
                        capitalizeNext = false;
                    } else {
                        result.append(Character.toLowerCase(c));
                    }
                }
            }
            
            return result.toString();
        });
    }
    
    public static String camelCaseToUnderscore(String camelCase) {
        return SNAKE_CASE_CACHE.computeIfAbsent(camelCase, name -> {
            StringBuilder result = new StringBuilder();
            
            for (int i = 0; i < name.length(); i++) {
                char c = name.charAt(i);
                if (Character.isUpperCase(c)) {
                    if (i > 0) {
                        result.append('_');
                    }
                    result.append(Character.toLowerCase(c));
                } else {
                    result.append(c);
                }
            }
            
            return result.toString();
        });
    }
}
```

## é«˜çº§æŠ€æœ¯ç‰¹æ€§

### 1. ä¼ä¸šçº§SQLè§£æå¼•æ“

Slavopolis-JDBCå†…ç½®äº†ä¸€ä¸ªå¼ºå¤§çš„SQLè§£æå¼•æ“ï¼Œèƒ½å¤Ÿæ™ºèƒ½å¤„ç†å¤æ‚çš„SQLç»“æ„ã€‚

#### SQLè§£ææ¶æ„

<function_calls>
<invoke name="create_diagram">
<parameter name="content">graph TB
    A[Original SQL] --> B[SQL Tokenizer]
    B --> C[Syntax Parser]
    C --> D[Structure Analyzer]
    D --> E[Query Optimizer]
    E --> F[Security Validator]
    F --> G[Optimized SQL]
    
    subgraph "è§£æç»„ä»¶"
        H[CTE Parser]
        I[Union Parser]
        J[Subquery Parser]
        K[Join Parser]
    end
    
    subgraph "ä¼˜åŒ–ç­–ç•¥"
        L[Count SQL Builder]
        M[Page SQL Builder]
        N[Order By Remover]
        O[Index Hint Injector]
    end
    
    C --> H
    C --> I
    C --> J
    C --> K
    
    E --> L
    E --> M
    E --> N
    E --> O
    
    style A fill:#ffcdd2
    style G fill:#c8e6c9
    style C fill:#e1f5fe
    style E fill:#f3e5f5

#### æ ¸å¿ƒè§£ææŠ€æœ¯

**1. çŠ¶æ€æœºSQLè§£æå™¨**

```java
public class SqlParser {
    
    private final String sql;
    private int position;
    private ParserState state;
    
    public String removeMainQueryOrderBy() {
        StringBuilder result = new StringBuilder();
        position = 0;
        state = ParserState.NORMAL;
        
        while (position < sql.length()) {
            char currentChar = sql.charAt(position);
            
            switch (state) {
                case NORMAL:
                    if (currentChar == '\'') {
                        state = ParserState.IN_STRING;
                        result.append(currentChar);
                    } else if (currentChar == '-' && peekNext() == '-') {
                        state = ParserState.IN_LINE_COMMENT;
                        result.append(currentChar);
                    } else if (currentChar == '/' && peekNext() == '*') {
                        state = ParserState.IN_BLOCK_COMMENT;
                        result.append(currentChar);
                    } else if (matchesOrderBy()) {
                        // æ£€æŸ¥æ˜¯å¦ä¸ºä¸»æŸ¥è¯¢çš„ORDER BY
                        if (isMainQueryOrderBy()) {
                            skipOrderByClause();
                            continue;
                        } else {
                            result.append(currentChar);
                        }
                    } else {
                        result.append(currentChar);
                    }
                    break;
                    
                case IN_STRING:
                    result.append(currentChar);
                    if (currentChar == '\'' && !isEscaped()) {
                        state = ParserState.NORMAL;
                    }
                    break;
                    
                case IN_LINE_COMMENT:
                    result.append(currentChar);
                    if (currentChar == '\n') {
                        state = ParserState.NORMAL;
                    }
                    break;
                    
                case IN_BLOCK_COMMENT:
                    result.append(currentChar);
                    if (currentChar == '*' && peekNext() == '/') {
                        result.append('/');
                        position++;
                        state = ParserState.NORMAL;
                    }
                    break;
            }
            
            position++;
        }
        
        return result.toString().trim();
    }
    
    private boolean isMainQueryOrderBy() {
        // æ£€æŸ¥æ‹¬å·æ·±åº¦ï¼Œç¡®ä¿ä¸åœ¨å­æŸ¥è¯¢ä¸­
        int parenthesesDepth = 0;
        int checkPosition = 0;
        
        while (checkPosition < position) {
            char c = sql.charAt(checkPosition);
            if (c == '(') parenthesesDepth++;
            else if (c == ')') parenthesesDepth--;
            checkPosition++;
        }
        
        return parenthesesDepth == 0;
    }
}
```

**2. æ™ºèƒ½è®¡æ•°SQLæ„å»ºå™¨**

```java
public class CountSqlBuilder {
    
    public String buildCountSql(String originalSql) {
        SqlStructure structure = analyzeSqlStructure(originalSql);
        
        switch (structure.getType()) {
            case CTE_QUERY:
                return handleCteCountSql(originalSql, structure);
            case UNION_QUERY:
                return handleUnionCountSql(originalSql, structure);
            case SIMPLE_SELECT:
                return handleSimpleSelectCountSql(originalSql, structure);
            case COMPLEX_SELECT:
                return handleComplexSelectCountSql(originalSql, structure);
            default:
                return wrapAsSubqueryCount(originalSql);
        }
    }
    
    private String handleSimpleSelectCountSql(String sql, SqlStructure structure) {
        // å¯¹äºç®€å•æŸ¥è¯¢ï¼Œç›´æ¥æ›¿æ¢SELECTå­å¥
        if (!structure.hasDistinct() && !structure.hasGroupBy() && !structure.hasHaving()) {
            String fromClause = sql.substring(structure.getFromIndex());
            String cleanFromClause = removeOrderByClause(fromClause);
            return "SELECT COUNT(*) " + cleanFromClause;
        }
        
        return wrapAsSubqueryCount(sql);
    }
    
    private String handleComplexSelectCountSql(String sql, SqlStructure structure) {
        // å¤æ‚æŸ¥è¯¢ä½¿ç”¨å­æŸ¥è¯¢åŒ…è£…
        String cleanSql = removeOrderByClause(sql);
        return "SELECT COUNT(*) FROM (" + cleanSql + ") AS complex_count_query";
    }
    
    private SqlStructure analyzeSqlStructure(String sql) {
        SqlStructure structure = new SqlStructure();
        String lowerSql = sql.toLowerCase();
        
        // åˆ†ææŸ¥è¯¢ç±»å‹
        if (lowerSql.startsWith("with")) {
            structure.setType(SqlType.CTE_QUERY);
        } else if (lowerSql.contains(" union ")) {
            structure.setType(SqlType.UNION_QUERY);
        } else if (hasComplexFeatures(lowerSql)) {
            structure.setType(SqlType.COMPLEX_SELECT);
        } else {
            structure.setType(SqlType.SIMPLE_SELECT);
        }
        
        // åˆ†ææŸ¥è¯¢ç‰¹å¾
        structure.setHasDistinct(lowerSql.contains("select distinct"));
        structure.setHasGroupBy(lowerSql.contains(" group by "));
        structure.setHasHaving(lowerSql.contains(" having "));
        structure.setFromIndex(findFromClauseIndex(sql));
        
        return structure;
    }
}
```

### 2. é«˜æ€§èƒ½ç¼“å­˜ç³»ç»Ÿ

#### å¤šçº§ç¼“å­˜æ¶æ„

<function_calls>
<invoke name="create_diagram">
<parameter name="content">graph TB
    A[Query Request] --> B[L1 Cache<br/>RowMapper Cache]
    B --> C{Cache Hit?}
    C -->|Yes| D[Return Cached Mapper]
    C -->|No| E[L2 Cache<br/>Metadata Cache]
    E --> F{Cache Hit?}
    F -->|Yes| G[Build Mapper from Metadata]
    F -->|No| H[Reflection Analysis]
    H --> I[Build New Mapper]
    I --> J[Update L2 Cache]
    J --> K[Update L1 Cache]
    G --> K
    K --> D
    
    subgraph "ç¼“å­˜ç­–ç•¥"
        L[LRU Eviction]
        M[TTL Expiration]
        N[Size Limit]
    end
    
    B --> L
    E --> M
    B --> N
    
    style A fill:#e3f2fd
    style D fill:#c8e6c9
    style B fill:#fff3e0
    style E fill:#f3e5f5

## Spring Boot é›†æˆè®¾è®¡

### è‡ªåŠ¨è£…é…æœºåˆ¶

Slavopolis-JDBCé‡‡ç”¨Spring Bootçš„è‡ªåŠ¨è£…é…æœºåˆ¶ï¼Œå®ç°é›¶é…ç½®å¯åŠ¨ã€‚

```java
@Slf4j
@AutoConfiguration(after = DataSourceAutoConfiguration.class)
@ConditionalOnClass({DataSource.class, NamedParameterJdbcTemplate.class})
@ConditionalOnProperty(prefix = "slavopolis.jdbc", name = "enabled", havingValue = "true", matchIfMissing = true)
@EnableConfigurationProperties({JdbcProperties.class, SqlSecurityConfig.class})
public class JdbcAutoConfiguration {

    @Bean
    @Primary
    @ConditionalOnMissingBean(JdbcOperations.class)
    public EnhancedJdbcTemplate enhancedJdbcTemplate(
            NamedParameterJdbcTemplate namedParameterJdbcTemplate,
            DataSourceTransactionManager transactionManager,
            TransactionDefinition transactionDefinition,
            JdbcProperties properties,
            SqlSecurityConfig securityConfig) {
        
        EnhancedJdbcTemplate template = new EnhancedJdbcTemplate(
            namedParameterJdbcTemplate, 
            transactionManager, 
            transactionDefinition,
            securityConfig
        );
        
        // åº”ç”¨é…ç½®
        template.setDefaultLoggingEnabled(properties.isDefaultLoggingEnabled());
        template.setDefaultPageSize(properties.getDefaultPageSize());
        template.setMaxPageSize(properties.getMaxPageSize());
        
        log.info("Enhanced JDBC Template configured successfully");
        return template;
    }
}
```

### é…ç½®å±æ€§ç»‘å®š

```java
@Data
@ConfigurationProperties(prefix = "slavopolis.jdbc")
public class JdbcProperties {
    
    private boolean enabled = true;
    private boolean defaultLoggingEnabled = true;
    private int defaultPageSize = 20;
    private int maxPageSize = 1000;
    
    private Monitor monitor = new Monitor();
    private Security security = new Security();
    private Transaction transaction = new Transaction();
    private Mapping mapping = new Mapping();
    
    // å†…éƒ¨é…ç½®ç±»...
}
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. è¿æ¥æ± ä¼˜åŒ–

```yaml
spring:
  datasource:
    hikari:
      # è¿æ¥æ± æ ¸å¿ƒé…ç½®
      maximum-pool-size: 20          # æœ€å¤§è¿æ¥æ•°
      minimum-idle: 5                # æœ€å°ç©ºé—²è¿æ¥æ•°
      connection-timeout: 30000      # è¿æ¥è¶…æ—¶æ—¶é—´
      idle-timeout: 600000           # ç©ºé—²è¿æ¥è¶…æ—¶æ—¶é—´
      max-lifetime: 1800000          # è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
      
      # æ€§èƒ½ä¼˜åŒ–é…ç½®
      leak-detection-threshold: 60000 # è¿æ¥æ³„æ¼æ£€æµ‹é˜ˆå€¼
      validation-timeout: 5000        # è¿æ¥éªŒè¯è¶…æ—¶æ—¶é—´
      
      # æ•°æ®åº“ç‰¹å®šä¼˜åŒ–
      data-source-properties:
        cachePrepStmts: true
        prepStmtCacheSize: 250
        prepStmtCacheSqlLimit: 2048
        useServerPrepStmts: true
        useLocalSessionState: true
        rewriteBatchedStatements: true
        cacheResultSetMetadata: true
        cacheServerConfiguration: true
        elideSetAutoCommits: true
        maintainTimeStats: false
```

### 2. æ‰¹å¤„ç†ä¼˜åŒ–

```java
public class BatchOptimizer {
    
    private static final int OPTIMAL_BATCH_SIZE = 500;
    private static final int MAX_BATCH_SIZE = 1000;
    
    public <T> void optimizedBatchInsert(List<T> entities, String sql, Function<T, Map<String, Object>> paramMapper) {
        if (entities.isEmpty()) return;
        
        // åŠ¨æ€è°ƒæ•´æ‰¹å¤„ç†å¤§å°
        int batchSize = calculateOptimalBatchSize(entities.size());
        
        for (int i = 0; i < entities.size(); i += batchSize) {
            List<T> batch = entities.subList(i, Math.min(i + batchSize, entities.size()));
            
            Map<String, Object>[] batchParams = batch.stream()
                .map(paramMapper)
                .toArray(Map[]::new);
            
            jdbcOperations.batchUpdate(sql, batchParams);
        }
    }
    
    private int calculateOptimalBatchSize(int totalSize) {
        if (totalSize <= OPTIMAL_BATCH_SIZE) {
            return totalSize;
        }
        
        // æ ¹æ®æ€»æ•°é‡åŠ¨æ€è°ƒæ•´æ‰¹å¤„ç†å¤§å°
        int calculatedSize = Math.min(OPTIMAL_BATCH_SIZE, totalSize / 4);
        return Math.max(calculatedSize, 100);
    }
}
```

### 3. æŸ¥è¯¢ä¼˜åŒ–

```java
public class QueryOptimizer {
    
    public String optimizeQuery(String originalSql) {
        String optimizedSql = originalSql;
        
        // 1. ç§»é™¤ä¸å¿…è¦çš„ORDER BYï¼ˆç”¨äºè®¡æ•°æŸ¥è¯¢ï¼‰
        if (isCountQuery(optimizedSql)) {
            optimizedSql = removeOrderByClause(optimizedSql);
        }
        
        // 2. æ·»åŠ æŸ¥è¯¢æç¤º
        optimizedSql = addQueryHints(optimizedSql);
        
        // 3. ä¼˜åŒ–JOINé¡ºåº
        optimizedSql = optimizeJoinOrder(optimizedSql);
        
        return optimizedSql;
    }
    
    private String addQueryHints(String sql) {
        // æ ¹æ®æŸ¥è¯¢æ¨¡å¼æ·»åŠ é€‚å½“çš„æŸ¥è¯¢æç¤º
        if (sql.toLowerCase().contains("select count(*)")) {
            return sql.replace("SELECT COUNT(*)", "SELECT /*+ USE_INDEX */ COUNT(*)");
        }
        
        return sql;
    }
}
```

## æ‰©å±•æ€§è®¾è®¡

### 1. æ’ä»¶åŒ–æ¶æ„

```java
public interface JdbcPlugin {
    
    String getName();
    
    void initialize(JdbcPluginContext context);
    
    void beforeExecution(SqlExecutionContext context);
    
    void afterExecution(SqlExecutionContext context);
    
    void onException(SqlExecutionContext context, Exception exception);
}

@Component
public class PluginManager {
    
    private final List<JdbcPlugin> plugins = new ArrayList<>();
    
    public void registerPlugin(JdbcPlugin plugin) {
        plugins.add(plugin);
        plugin.initialize(createPluginContext());
    }
    
    public void executeWithPlugins(SqlExecutionContext context, Runnable execution) {
        // å‰ç½®å¤„ç†
        plugins.forEach(plugin -> plugin.beforeExecution(context));
        
        try {
            execution.run();
            // åç½®å¤„ç†
            plugins.forEach(plugin -> plugin.afterExecution(context));
        } catch (Exception e) {
            // å¼‚å¸¸å¤„ç†
            plugins.forEach(plugin -> plugin.onException(context, e));
            throw e;
        }
    }
}
```

### 2. è‡ªå®šä¹‰æ‰©å±•ç‚¹

```java
public interface SqlInterceptor {
    
    String interceptSql(String originalSql, Map<String, Object> params);
    
    Map<String, Object> interceptParams(String sql, Map<String, Object> originalParams);
    
    <T> T interceptResult(String sql, Map<String, Object> params, T originalResult);
}

public interface RowMapperProvider {
    
    boolean supports(Class<?> targetType);
    
    <T> RowMapper<T> createRowMapper(Class<T> targetType);
}
```

## æ€»ç»“ä¸å±•æœ›

### æŠ€æœ¯åˆ›æ–°ç‚¹

1. **å¤šå±‚å®‰å…¨é˜²æŠ¤ä½“ç³»**ï¼šæ„å»ºäº†ä»SQLè§£æåˆ°å‚æ•°éªŒè¯çš„å…¨æ–¹ä½å®‰å…¨é˜²æŠ¤æœºåˆ¶
2. **æ™ºèƒ½SQLè§£æå¼•æ“**ï¼šæ”¯æŒå¤æ‚SQLç»“æ„çš„è§£æå’Œä¼˜åŒ–ï¼ŒåŒ…æ‹¬CTEã€UNIONã€å­æŸ¥è¯¢ç­‰
3. **é«˜æ€§èƒ½ç›‘æ§ç³»ç»Ÿ**ï¼šæä¾›å®æ—¶æ€§èƒ½ç›‘æ§ã€æ…¢æŸ¥è¯¢åˆ†æã€ä¼˜åŒ–å»ºè®®ç­‰åŠŸèƒ½
4. **æ™ºèƒ½ç»“æœæ˜ å°„**ï¼šè‡ªåŠ¨é©¼å³°è½¬æ¢ã€ç±»å‹å®‰å…¨æ˜ å°„ã€ç¼“å­˜ä¼˜åŒ–ç­‰ç‰¹æ€§
5. **ä¼ä¸šçº§äº‹åŠ¡ç®¡ç†**ï¼šæ”¯æŒç¼–ç¨‹å¼äº‹åŠ¡ã€å›è°ƒå¼äº‹åŠ¡ç­‰å¤šç§äº‹åŠ¡ç®¡ç†æ¨¡å¼

### æ¶æ„ä¼˜åŠ¿

- **æ¨¡å—åŒ–è®¾è®¡**ï¼šå„ç»„ä»¶èŒè´£æ¸…æ™°ï¼Œæ˜“äºæ‰©å±•å’Œç»´æŠ¤
- **é«˜æ€§èƒ½**ï¼šå¤šçº§ç¼“å­˜ã€æ‰¹å¤„ç†ä¼˜åŒ–ã€è¿æ¥æ± ç®¡ç†ç­‰æ€§èƒ½ä¼˜åŒ–æªæ–½
- **å®‰å…¨æ€§**ï¼šå¤šå±‚å®‰å…¨éªŒè¯ï¼Œæœ‰æ•ˆé˜²èŒƒSQLæ³¨å…¥ç­‰å®‰å…¨é£é™©
- **æ˜“ç”¨æ€§**ï¼šç®€æ´çš„APIè®¾è®¡ï¼Œé›¶é…ç½®å¯åŠ¨ï¼Œé™ä½å­¦ä¹ æˆæœ¬
- **å¯è§‚æµ‹æ€§**ï¼šå®Œå–„çš„ç›‘æ§å’Œç»Ÿè®¡åŠŸèƒ½ï¼Œä¾¿äºæ€§èƒ½è°ƒä¼˜

### æœªæ¥å‘å±•æ–¹å‘

1. **åˆ†å¸ƒå¼æ”¯æŒ**ï¼šæ”¯æŒåˆ†åº“åˆ†è¡¨ã€è¯»å†™åˆ†ç¦»ç­‰åˆ†å¸ƒå¼æ•°æ®åº“ç‰¹æ€§
2. **AIé©±åŠ¨ä¼˜åŒ–**ï¼šåŸºäºæœºå™¨å­¦ä¹ çš„SQLä¼˜åŒ–å»ºè®®å’Œæ€§èƒ½é¢„æµ‹
3. **äº‘åŸç”Ÿé›†æˆ**ï¼šä¸Kubernetesã€Service Meshç­‰äº‘åŸç”ŸæŠ€æœ¯æ·±åº¦é›†æˆ
4. **å¤šæ•°æ®æºæ”¯æŒ**ï¼šæ”¯æŒNoSQLã€æ—¶åºæ•°æ®åº“ç­‰å¤šç§æ•°æ®æº
5. **å¯è§†åŒ–ç®¡ç†**ï¼šæä¾›Webç®¡ç†ç•Œé¢ï¼Œæ”¯æŒé…ç½®ç®¡ç†ã€ç›‘æ§å±•ç¤ºç­‰åŠŸèƒ½

### æŠ€æœ¯ä»·å€¼

Slavopolis-JDBCä¸ä»…ä»…æ˜¯ä¸€ä¸ªæ•°æ®è®¿é—®æ¡†æ¶ï¼Œæ›´æ˜¯ä¼ä¸šçº§åº”ç”¨å¼€å‘çš„æœ€ä½³å®è·µé›†åˆã€‚å®ƒé€šè¿‡åˆ›æ–°çš„æ¶æ„è®¾è®¡å’Œç²¾å¿ƒçš„æŠ€æœ¯é€‰å‹ï¼Œä¸ºå¼€å‘è€…æä¾›äº†ä¸€ä¸ªå®‰å…¨ã€é«˜æ•ˆã€æ˜“ç”¨çš„æ•°æ®è®¿é—®è§£å†³æ–¹æ¡ˆï¼Œæ˜¾è‘—æå‡äº†å¼€å‘æ•ˆç‡å’Œåº”ç”¨è´¨é‡ã€‚

åœ¨å½“å‰å¾®æœåŠ¡ã€äº‘åŸç”Ÿã€DevOpsç­‰æŠ€æœ¯è¶‹åŠ¿ä¸‹ï¼ŒSlavopolis-JDBCçš„è®¾è®¡ç†å¿µå’ŒæŠ€æœ¯å®ç°å…·æœ‰é‡è¦çš„å‚è€ƒä»·å€¼ï¼Œä¸ºæ„å»ºç°ä»£åŒ–çš„ä¼ä¸šçº§åº”ç”¨æä¾›äº†åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚

---

*é€šè¿‡æ·±å…¥ç†è§£Slavopolis-JDBCçš„æŠ€æœ¯åŸç†å’Œè®¾è®¡æ€æƒ³ï¼Œå¼€å‘è€…å¯ä»¥æ›´å¥½åœ°è¿ç”¨è¿™ä¸€å¼ºå¤§çš„å·¥å…·ï¼Œæ„å»ºå‡ºæ›´åŠ å®‰å…¨ã€é«˜æ•ˆã€å¯ç»´æŠ¤çš„ä¼ä¸šçº§åº”ç”¨ã€‚* 
